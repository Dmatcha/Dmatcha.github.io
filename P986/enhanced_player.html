<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="description" content="Enhanced player character management interface with modern web standards" />
  <title>Player: Enhanced</title>

  <style>
    :root{
      /* Base font size for rem calculations */
      font-size: 16px;
      
      /* Modern CSS Custom Properties */
      --bg:#121212;
      --card:#1f1f1f;
      --muted:#9aa3ad;
      --accent-purple: rgba(106,27,154,0.22);
      --gold: #D4AF37;
      --blue-cool:#66ccff;
      --glass: rgba(255,255,255,0.04);
      --heart-white: #ffffff;
      --heart-blue: #4da6ff;
      --heart-purple: #9b59b6;
      --heart-red: #ff8fa3;
      --scarlet-pink: #ff8fa3;
      
      /* Animation timing variables for consistency */
      --fade-in-duration: 0.3s;
      --fade-out-duration: 2s;
      --icon-linger-duration: 3s;
      --easing-smooth: cubic-bezier(0.4, 0, 0.2, 1);
      --easing-bounce: cubic-bezier(0.68, -0.55, 0.265, 1.55);
      
      /* Professional press-and-hold timing */
      --hold-duration: 2.5s;
      --hold-easing: cubic-bezier(0.25, 0.46, 0.45, 0.94);
      --progress-color: #ffffff;
      --progress-bg: rgba(255, 255, 255, 0.2);
      --flash-color: #ffffff;
      
      /* Modern spacing system */
      --space-xs: 0.25rem;
      --space-sm: 0.5rem;
      --space-md: 1rem;
      --space-lg: 1.5rem;
      --space-xl: 2rem;
      
      /* Modern border radius system */
      --radius-sm: 0.5rem;
      --radius-md: 0.75rem;
      --radius-lg: 1.25rem;
      --radius-xl: 1.5rem;
    }

    /* Modern CSS Reset and Base Styles */
    *, *::before, *::after {
      box-sizing: border-box;
    }

    html {
      line-height: 1.5;
      -webkit-text-size-adjust: 100%;
      scroll-behavior: smooth;
    }

    body{
      margin:0;
      min-height:100vh;
      font-family: "Inter", "Segoe UI", system-ui, -apple-system, BlinkMacSystemFont, Arial, sans-serif;
      background: linear-gradient(180deg,#0f0f12 0%, #141417 60%);
      color:#e9eef6;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    /* Modern Focus Management */
    :focus-visible {
      outline: 2px solid #4caf50;
      outline-offset: 2px;
      border-radius: 4px;
    }

    /* Container and Layout */
    .container {
      max-width: 56.25rem;
      margin: 0 auto;
      padding: var(--space-md);
    }

    .skip-link {
      position: absolute;
      top: -40px;
      left: 6px;
      background: #000;
      color: #fff;
      padding: 8px;
      text-decoration: none;
      z-index: 100;
    }

    .skip-link:focus {
      top: 6px;
    }

    /* Player name - Modern Input Styling */
    #playerName{
      width:100%;
      display:block;
      font-size:2.0rem;
      text-align:center;
      background:transparent;
      color: #fff;
      border: 0;
      border-bottom: 2px solid rgba(255,255,255,0.1);
      outline:0;
      padding: var(--space-sm) var(--space-xs);
      margin-bottom: var(--space-lg);
      transition: border-color 0.2s ease;
    }
    #playerName:focus {
      border-bottom-color: #4caf50;
    }
    #playerName::placeholder{ 
      color: rgba(255,255,255,0.35); 
    }

    /* Modern Grid Layout for Bars */
    .bars {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(20rem, 1fr));
      gap: var(--space-lg);
      margin-bottom: var(--space-xl);
    }

    @media (max-width: 45rem) {
      .bars { 
        grid-template-columns: 1fr; 
        grid-auto-rows: min-content;
      }
      .bar-card[data-key="life"]     { grid-row: 1; }
      .bar-card[data-key="stamina"]  { grid-row: 2; }
      .bar-card[data-key="empower"]  { grid-row: 3; }
      .bar-card[data-key="mana"]     { grid-row: 4; }
      .bar-card[data-key="energy"]   { grid-row: 5; }
      .bar-card[data-key="coalesce"] { grid-row: 6; }
    }

    /* Modern Card Design */
    .bar-card{
      background: linear-gradient(180deg, rgba(100,100,100,0.03), rgba(200,200,200,0.07));
      border-radius: var(--radius-lg);
      padding: var(--space-md) var(--space-lg);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: var(--space-lg);
      box-shadow: 0 0.375rem 1.125rem rgba(0,0,0,0.6);
      transition: transform .14s ease, box-shadow .14s ease;
      position: relative;
      overflow: hidden;
    }
    .bar-card:hover{ 
      transform: translateY(-0.125rem); 
      box-shadow: 0 1.25rem 1.875rem rgba(0,0,0,0.7); 
    }

    .bar-left{
      display:flex;
      align-items:center;
      gap: var(--space-md);
      min-width: 0;
      position: relative;
    }

    .bar-dot{
      width: 2.2rem;
      height: 2.2rem;
      border-radius:50%;
      box-shadow: 0 0.125rem 0.375rem rgba(0,0,0,0.6), inset 0 -0.0625rem 0 rgba(255,255,255,0.05);
      flex: 0 0 auto;
      position: relative;
    }
    .dot-life{ background: linear-gradient(180deg,#5fd08f,#2fb96b); }
    .dot-stamina{ background: linear-gradient(180deg,#6fb8ff,#2b74ff); }
    .dot-mana{ background: linear-gradient(180deg,#ffc46b,#ff9a2b); }
    .dot-energy{ background: linear-gradient(180deg,#6ff0ff,#13b6ff); }
    .dot-empower{ background: linear-gradient(180deg,#ff4d4d,#DC143C); }
    .dot-coalesce{ background: linear-gradient(180deg,#f5f7fa,#d9dde6); border:0.0625rem solid rgba(255,255,255,0.06); }

    /* Modern Icon System */
    .bar-icon {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0.85);
      width: 2.3rem;
      height: 2.3rem;
      opacity: 0;
      pointer-events: none;
      z-index: 10;
      filter: drop-shadow(0 0.25rem 0.5rem rgba(0, 0, 0, 0.3));
      
      will-change: opacity, transform;
      backface-visibility: hidden;
      
      transition: 
        opacity var(--fade-in-duration) var(--easing-smooth),
        transform var(--fade-in-duration) var(--easing-bounce);
    }

    .bar-icon.visible {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1);
    }

    .bar-icon.fading {
      opacity: 0;
      transform: translate(-50%, -50%) scale(0.8);
      transition: 
        opacity var(--fade-out-duration) var(--easing-smooth),
        transform var(--fade-out-duration) var(--easing-smooth);
    }

    .bar-icon img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      image-rendering: -webkit-optimize-contrast;
      image-rendering: crisp-edges;
      filter: drop-shadow(0 0.125rem 0.25rem rgba(0, 0, 0, 0.2));
      transition: filter var(--fade-in-duration) var(--easing-smooth);
    }

    .bar-card:hover .bar-icon img {
      filter: drop-shadow(0 0.25rem 0.5rem rgba(0, 0, 0, 0.3)) brightness(1.1);
    }

    .bar-label{ 
      font-weight:600; 
      font-size:1.38rem; 
      color:#f1f5fb; 
      white-space:nowrap; 
    }
    .bar-controls{ 
      display:flex; 
      align-items:center; 
      gap: var(--space-xs); 
      padding-right: var(--space-xs); 
    }

    .bar-value{
      width:5rem;
      text-align:center;
      font-weight:700;
      font-size:1.10rem;
      color:#ffffff;
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
    }

    /* Modern Button System */
    .btn {
      -webkit-appearance:none;
      appearance:none;
      border:0;
      background: rgba(255,255,255,0.09);
      color: #fff;
      padding: var(--space-xs) var(--space-sm);
      border-radius: var(--radius-sm);
      cursor:pointer;
      font-weight:700;
      transition: transform .12s ease, background .12s ease, box-shadow .12s ease;
    }
    .btn:active{ transform: scale(.97); }
    .btn:disabled{ 
      opacity: 0.3; 
      cursor: not-allowed; 
    }
    .btn:hover:not(:disabled) { 
      background: #ff00ff; 
    }

    .btn-icon {
      padding: var(--space-xs);
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    .btn-icon svg {
      width: 2rem;
      height: 2rem;
      color: white;
      transition: transform 0.2s ease, color 0.2s ease;
    }

    .btn-icon:hover:not(:disabled) svg {
      transform: scale(1.10);
      color: #ff00ff;
    }

    /* Modern Attributes Grid */
    .attributes{
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(7.5rem, 1fr));
      gap: var(--space-lg);
      margin-top: var(--space-xl);
    }

    /* Modern Attribute Cards */
    .attr{
      background: linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0.02));
      border-radius: var(--radius-md);
      padding: var(--space-md);
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      gap: var(--space-sm);
      cursor:pointer;
      transition: box-shadow .16s ease, border-color .16s ease;
      user-select:none;
      
      /* Professional touch target sizing */
      min-height: 3rem;
      min-width: 3rem;
      
      touch-action: manipulation;
      
      position: relative;
      overflow: visible;
      
      /* Modern border */
      border: 1px solid transparent;
    }
    
    /* Hover state */
    .attr:hover:not(.mobile-only) {
      box-shadow: 0 0 0.75rem rgba(106, 27, 154, 0.6);
    }
    
    /* Press-and-hold visual states */
    .attr.holding {
      box-shadow: 0 0 1rem rgba(255, 255, 255, 0.5);
      animation: progressiveShadow var(--hold-duration) ease-out forwards;
    }
    
    /* Success flash animation */
    .attr.flash {
      animation: goldFlash 1.0s ease-out forwards;
    }

    /* Click animation for Luck attribute */
    .attr.luck-clickable {
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    .attr.luck-clickable:active {
      transform: scale(0.98);
    }
    
    .attr.luck-clickable.clicked {
      animation: luckClickAnimation 0.3s ease-out;
    }

    .attr .attr-label{ 
      font-weight:700; 
      color:#f4f6fb; 
      white-space: nowrap;
      font-size: 0.9rem;
    }
    
    .attr .attr-val{ 
      font-weight:800; 
      font-size:1.05rem; 
      color:#eaeef8; 
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
    }

    /* Modern Progress Ring Animation */
    .progress-ring {
      position: absolute;
      top: -0.25rem;
      left: -0.25rem;
      right: -0.25rem;
      bottom: -0.25rem;
      border-radius: var(--radius-md);
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.25s ease;
    }
    
    .attr.holding .progress-ring {
      opacity: 1;
    }
    
    .progress-ring svg {
      width: 100%;
      height: 100%;
      border-radius: var(--radius-md);
    }
    
    .progress-ring circle {
      fill: none;
      stroke-width: 0.2rem;
      stroke-linecap: round;
      transform-origin: center;
      transform: rotate(-90deg);
    }
    
    .progress-ring .progress-bg {
      stroke: var(--progress-bg);
    }
    
    .progress-ring .progress-bar {
      stroke: var(--progress-color);
      stroke-dasharray: 251.327;
      stroke-dashoffset: 251.327;
      animation: none;
    }
    
    .attr.holding .progress-bar {
      animation: fillProgress var(--hold-duration) var(--hold-easing) forwards;
    }
    
    @keyframes fillProgress {
      0% {
        stroke-dashoffset: var(--circumference, 251.327);
      }
      100% {
        stroke-dashoffset: 0;
      }
    }

    @keyframes progressiveShadow {
      0% { box-shadow: 0 0 1rem rgba(255, 255, 255, 0.4); }
      50% { box-shadow: 0 0 1.5rem rgba(255, 255, 255, 0.7); }
      100% { box-shadow: 0 0 2rem rgba(255, 255, 255, 0.9); }
    }
    
    @keyframes goldFlash {
      0% { box-shadow: 0 0 2rem rgba(255, 255, 255, 0.9); }
      50% { box-shadow: 0 0 2.5rem rgba(255, 215, 0, 1.0); }
      100% { box-shadow: 0 0 1.5rem rgba(255, 215, 0, 0.6); }
    }
    
    @keyframes luckClickAnimation {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); box-shadow: 0 0 1rem rgba(212, 175, 55, 0.6); }
      100% { transform: scale(1); }
    }
    
    .pulse { animation: goldFlash 0.4s ease-out forwards; }

    /* Special Luck Styling */
    .attr.luck{
      border: 0.0625rem solid var(--gold);
      box-shadow: 0 0.375rem 1.5rem rgba(212,175,55,0.12), inset 0 0.0625rem 0 rgba(255,255,255,0.03);
      --progress-color: var(--gold);
      --progress-bg: rgba(212, 175, 55, 0.2);
      --flash-color: var(--gold);
    }
    
    .attr.luck.cooling{ 
      border-color: transparent; 
      box-shadow: none; 
    }
    
    .attr.luck.holding {
      border-color: var(--gold);
      box-shadow: 0 0 1rem rgba(255, 255, 255, 0.4);
      animation: progressiveShadow var(--hold-duration) ease-out forwards;
    }
    
    .attr.luck.flash {
      border-color: var(--gold);
      box-shadow: 0 0 1.35rem var(--gold);
    }

    /* Responsive Design */
    @media(max-width:28rem){
      .bar-card{ padding: var(--space-sm); }
      .bar-controls{ padding-right: var(--space-sm); }
      .attributes{ gap: var(--space-lg); margin-top: var(--space-xl); }
      
      .attr {
        min-height: 2rem;
        min-width: 2rem;
      }
      
      .attr .attr-label {
        font-size: 0.85rem;
      }
      
      .attr .attr-val {
        font-size: 1rem;
      }
    }

    /* Mobile-specific touch handling */
    @media (pointer: coarse) {
      .attr {
        touch-action: manipulation;
        -webkit-tap-highlight-color: transparent;
        user-select: none;
      }
      
      .attr.mobile-only:hover {
        box-shadow: 0 0 0.5rem rgba(140, 50, 230, 0.6);
      }
    }

    /* Modern Fixed Buttons */
    #resetBtn {
      position: fixed;
      top: var(--space-sm);
      left: var(--space-sm);
      background: #1f1f1f;
      color: white;
      border: none;
      border-radius: var(--radius-sm);
      padding: var(--space-xs) var(--space-sm);
      font-size: 0.9rem;
      font-weight: bold;
      cursor: pointer;
      z-index: 1000;
      transition: background 0.2s;
    }
    #resetBtn:hover { background: #ff4d4d; }

    /* Modern Heart Button */
    #heartBtn {
      position: fixed;
      top: var(--space-sm);
      right: 1.875rem;
      width: 2.5rem;
      height: 2.5rem;
      background: transparent;
      border: 0.1875rem solid white;
      border-radius: var(--radius-sm);
      cursor: pointer;
      z-index: 1001;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
    }
    #heartBtn svg {
      width: 1.5rem;
      height: 1.5rem;
      fill: transparent;
      stroke: white;
      stroke-width: 2;
      transition: all 0.3s ease;
    }
    #heartBtn.active {
      background: var(--scarlet-pink);
      border-color: #333;
    }
    #heartBtn.active svg {
      fill: var(--scarlet-pink);
      stroke: #333;
    }
    #heartBtn:hover:not(.disabled) {
      transform: scale(1.05);
    }
    #heartBtn.disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* Modern Overlay System */
    #relationshipOverlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(15, 15, 18, 0.85);
      backdrop-filter: blur(0.5rem);
      -webkit-backdrop-filter: blur(0.5rem);
      z-index: 999;
      display: none;
      overflow-y: auto;
      padding: 3.75rem var(--space-md) var(--space-lg);
    }
    #relationshipOverlay.visible {
      display: block;
    }

    .relationship-content {
      max-width: 41.25rem;
      margin: 0 auto;
    }

    .relationship-title {
      text-align: center;
      font-size: 1.8rem;
      font-weight: 700;
      margin-bottom: 1.5rem;
      color: #fff;
    }

    /* Bottom Stats Bar */
    #bottomStats {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(18, 18, 18, 0.95);
      padding: var(--space-sm) var(--space-xs);
      text-align: center;
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
      border-top: 0.0625rem solid rgba(255, 255, 255, 0.1);
      z-index: 1;
    }
    #bottomStats span {
      display: inline-block;
      margin: var(--space-xs) var(--space-xs);
      font-weight: bold;
      color: #fff;
    }
    #bottomStats .stat-label {
      color: #FFF;
      font-weight: 600;
    }
    #bottomStats .stat-value {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 5ch;
      padding: var(--space-xs) var(--space-md);
      box-sizing: border-box;
      border-radius: var(--radius-sm);
      border: 0.125rem solid rgba(230, 227, 200, 0.25);
      font-variant-numeric: tabular-nums;
      font-feature-settings: "tnum";
    }

    /* Modern Accessibility */
    @media (prefers-reduced-motion: reduce) {
      *, *::before, *::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
      }
      
      .bar-icon {
        opacity: 1 !important;
        transform: translate(-50%, -50%) scale(1) !important;
      }
      
      .progress-ring .progress-bar {
        stroke-dashoffset: 0 !important;
      }
    }

    @media (prefers-contrast: high) {
      .bar-icon {
        filter: drop-shadow(0 0.125rem 0.25rem rgba(0, 0, 0, 0.8));
      }
      
      .progress-ring circle {
        stroke-width: 0.25rem;
      }
    }

    /* Modern Attribute Icons */
    .attr-value-wrap {
      display: inline-flex;
      align-items: center;
      gap: var(--space-xs);
    }

    .attr-icon {
      width: 2rem;
      height: 2rem;
      padding: 0.0625rem;
      object-fit: contain;
      image-rendering: -webkit-optimize-contrast;
      image-rendering: crisp-edges;
      filter: drop-shadow(0 0.125rem 0.1875rem rgba(0,0,0,0.4));
      flex-shrink: 0;
    }

    /* Utility Classes */
    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    .muted{ color: rgba(255,255,255,0.54); font-size:0.88rem; }
    .center{ text-align:center; }

    /* Loading States */
    .loading {
      opacity: 0.6;
      pointer-events: none;
    }

    .spinner {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid rgba(255,255,255,.3);
      border-radius: 50%;
      border-top-color: #fff;
      animation: spin 1s ease-in-out infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

  </style>
</head>
<body>
  <a href="#main-content" class="skip-link">Skip to main content</a>
  
  <button id="resetBtn" aria-label="Reset all data">RESET</button>
  
  <!-- Heart Button -->
  <button id="heartBtn" aria-label="Toggle Relationships" aria-expanded="false">
    <svg viewBox="0 0 24 24" aria-hidden="true">
      <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"/>
    </svg>
  </button>

  <!-- Relationship Overlay -->
  <div id="relationshipOverlay" role="dialog" aria-modal="true" aria-labelledby="relationshipTitle">
    <div class="relationship-content">
      <h2 class="relationship-title" id="relationshipTitle">Relationships</h2>
      <div id="npcList" role="list"></div>
      <button class="add-npc-btn" id="addNpcBtn">
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <line x1="12" y1="5" x2="12" y2="19"/>
          <line x1="5" y1="12" x2="19" y2="12"/>
        </svg>
        <span>Add Character</span>
      </button>
    </div>
  </div>

  <main class="container" id="main-content">
    <input 
      id="playerName" 
      placeholder="PLAYER" 
      aria-label="Player name" 
      autocomplete="name"
      maxlength="50"
    />

    <section class="bars" id="bars" role="region" aria-label="Player stats"></section>

    <section class="attributes" id="attributes" role="region" aria-label="Player attributes"></section>
  </main>

  <div style="height: 3rem;"></div>
  
  <!-- Bottom Stats Bar -->
  <footer id="bottomStats" role="contentinfo">
    <span class="stat-label">Level:</span><span class="stat-value" id="levelValue">1</span>
    <span class="stat-label">Tinge:</span><span class="stat-value" id="tingeValue">0</span>
    <span class="stat-label">Arcane:</span><span class="stat-value" id="arcaneValue">0</span>
  </footer>

<script>
/**
 * Modern Utility Functions
 */
const Utils = {
  // Debounce function for performance optimization
  debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
      const later = () => {
        clearTimeout(timeout);
        func(...args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  },

  // Throttle function for scroll events
  throttle(func, limit) {
    let inThrottle;
    return function() {
      const args = arguments;
      const context = this;
      if (!inThrottle) {
        func.apply(context, args);
        inThrottle = true;
        setTimeout(() => inThrottle = false, limit);
      }
    };
  },

  // Safe localStorage operations
  storage: {
    set(key, value) {
      try {
        localStorage.setItem(key, JSON.stringify(value));
        return true;
      } catch (error) {
        console.warn('Failed to save to localStorage:', error);
        return false;
      }
    },
    get(key, fallback = null) {
      try {
        const value = localStorage.getItem(key);
        return value ? JSON.parse(value) : fallback;
      } catch (error) {
        console.warn('Failed to read from localStorage:', error);
        return fallback;
      }
    },
    remove(key) {
      try {
        localStorage.removeItem(key);
        return true;
      } catch (error) {
        console.warn('Failed to remove from localStorage:', error);
        return false;
      }
    }
  },

  // Generate unique IDs
  generateId() {
    return Date.now().toString(36) + Math.random().toString(36).substr(2);
  },

  // Format numbers with proper locale
  formatNumber(num) {
    return new Intl.NumberFormat().format(num);
  }
};

/**
 * Modern Touch Interaction Manager with Enhanced Accessibility
 */
class ModernTouchManager {
  constructor(options = {}) {
    this.config = {
      holdDuration: options.holdDuration || 2500,
      moveThreshold: options.moveThreshold || 10,
      showProgress: options.showProgress !== false,
      hapticFeedback: options.hapticFeedback !== false,
      ...options
    };
    
    this.activeHolds = new Map();
    this.isTouchDevice = this.detectTouchDevice();
    
    this.handlePointerDown = this.handlePointerDown.bind(this);
    this.handlePointerMove = this.handlePointerMove.bind(this);
    this.handlePointerUp = this.handlePointerUp.bind(this);
    this.handlePointerCancel = this.handlePointerCancel.bind(this);
  }
  
  detectTouchDevice() {
    return (
      'ontouchstart' in window ||
      navigator.maxTouchPoints > 0 ||
      navigator.msMaxTouchPoints > 0
    );
  }
  
  attach(element, onActivate, options = {}) {
    const elementOptions = { ...this.config, ...options };
    
    // Enhanced accessibility
    element.setAttribute('role', 'button');
    element.setAttribute('aria-label', options.ariaLabel || 'Press and hold to activate');
    element.setAttribute('tabindex', '0');
    
    // Prevent context menu on long press
    element.addEventListener('contextmenu', (e) => e.preventDefault());
    
    // Event listeners with passive option for performance
    element.addEventListener('pointerdown', (e) => this.handlePointerDown(e, element, onActivate, elementOptions), { passive: false });
    element.addEventListener('pointermove', (e) => this.handlePointerMove(e, element), { passive: true });
    element.addEventListener('pointerup', (e) => this.handlePointerUp(e, element), { passive: true });
    element.addEventListener('pointercancel', (e) => this.handlePointerCancel(e, element), { passive: true });
    element.addEventListener('pointerleave', (e) => this.handlePointerCancel(e, element), { passive: true });
    
    // Keyboard support
    element.addEventListener('keydown', (e) => {
      if (e.code === 'Space' || e.code === 'Enter') {
        e.preventDefault();
        this.simulateHold(element, onActivate, elementOptions);
      }
    });
    
    if (this.isTouchDevice) {
      element.classList.add('mobile-only');
    }
  }
  
  handlePointerDown(e, element, onActivate, options) {
    if (!this.isTouchDevice && e.pointerType !== 'mouse') return;
    
    e.preventDefault();
    
    const startX = e.clientX;
    const startY = e.clientY;
    const startTime = Date.now();
    
    if (options.showProgress) {
      this.createProgressRing(element);
    }
    
    element.classList.add('holding');
    
    const holdState = {
      timer: null,
      startX,
      startY,
      startTime,
      element,
      onActivate,
      options
    };
    
    this.activeHolds.set(element, holdState);
    
    holdState.timer = setTimeout(() => {
      this.completeHold(element, holdState);
    }, options.holdDuration);
    
    if (options.hapticFeedback && 'vibrate' in navigator) {
      navigator.vibrate(50);
    }
  }
  
  handlePointerMove(e, element) {
    const holdState = this.activeHolds.get(element);
    if (!holdState) return;
    
    const deltaX = Math.abs(e.clientX - holdState.startX);
    const deltaY = Math.abs(e.clientY - holdState.startY);
    
    if (deltaX > this.config.moveThreshold || deltaY > this.config.moveThreshold) {
      this.cancelHold(element, holdState);
    }
  }
  
  handlePointerUp(e, element) {
    const holdState = this.activeHolds.get(element);
    if (!holdState) return;
    
    const duration = Date.now() - holdState.startTime;
    
    if (duration >= holdState.options.holdDuration) {
      element.setAttribute('data-hold-activated', 'true');
    }
    
    this.cancelHold(element, holdState);
  }
  
  handlePointerCancel(e, element) {
    const holdState = this.activeHolds.get(element);
    if (!holdState) return;
    
    this.cancelHold(element, holdState);
  }
  
  completeHold(element, holdState) {
    if (holdState.options.hapticFeedback && 'vibrate' in navigator) {
      navigator.vibrate([100, 50, 100]);
    }
    
    element.classList.remove('holding');
    element.classList.add('flash');
    
    holdState.onActivate();
    
    setTimeout(() => {
      element.classList.remove('flash');
    }, 400);
    
    this.activeHolds.delete(element);
  }
  
  cancelHold(element, holdState) {
    clearTimeout(holdState.timer);
    element.classList.remove('holding');
    this.removeProgressRing(element);
    this.activeHolds.delete(element);
  }
  
  simulateHold(element, onActivate, options) {
    element.classList.add('holding');
    
    if (options.showProgress) {
      this.createProgressRing(element);
    }
    
    setTimeout(() => {
      element.classList.remove('holding');
      element.classList.add('flash');
      onActivate();
      
      setTimeout(() => {
        element.classList.remove('flash');
      }, 400);
    }, options.holdDuration);
  }
  
  createProgressRing(element) {
    if (element.querySelector('.progress-ring')) return;
    
    const progressRing = document.createElement('div');
    progressRing.className = 'progress-ring';
    
    const radius = 42;
    const circumference = 2 * Math.PI * radius;
    
    const progressColor = getComputedStyle(element).getPropertyValue('--progress-color').trim() || '#ffffff';
    const progressBg = getComputedStyle(element).getPropertyValue('--progress-bg').trim() || 'rgba(255, 255, 255, 0.2)';
    
    progressRing.innerHTML = `
      <svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
        <circle class="progress-bg" cx="50" cy="50" r="${radius}" stroke="${progressBg}"/>
        <circle class="progress-bar" cx="50" cy="50" r="${radius}" 
                stroke="${progressColor}"
                stroke-dasharray="${circumference} ${circumference}" 
                stroke-dashoffset="${circumference}"/>
      </svg>
    `;
    
    element.appendChild(progressRing);
    
    const progressBar = progressRing.querySelector('.progress-bar');
    progressBar.style.setProperty('--circumference', circumference);
  }
  
  removeProgressRing(element) {
    const progressRing = element.querySelector('.progress-ring');
    if (progressRing) {
      progressRing.remove();
    }
  }
}

/**
 * Modern Click Handler for Luck Attribute
 */
class ModernClickHandler {
  constructor() {
    this.handleClick = this.handleClick.bind(this);
    this.handleKeyDown = this.handleKeyDown.bind(this);
  }

  attach(element, onClick, options = {}) {
    element.classList.add('luck-clickable');
    element.setAttribute('role', 'button');
    element.setAttribute('aria-label', options.ariaLabel || 'Click to roll luck');
    element.setAttribute('tabindex', '0');

    // Click handler
    element.addEventListener('click', this.handleClick);
    
    // Keyboard support
    element.addEventListener('keydown', this.handleKeyDown);

    // Store callback for access
    element._clickHandler = onClick;
  }

  handleClick(event) {
    event.preventDefault();
    const element = event.currentTarget;
    const callback = element._clickHandler;
    
    if (callback) {
      callback();
    }
    
    // Visual feedback
    element.classList.add('clicked');
    setTimeout(() => {
      element.classList.remove('clicked');
    }, 300);
  }

  handleKeyDown(event) {
    if (event.code === 'Space' || event.code === 'Enter') {
      event.preventDefault();
      this.handleClick(event);
    }
  }
}

// Initialize managers
const touchManager = new ModernTouchManager({
  holdDuration: 2500,
  showProgress: true,
  hapticFeedback: true,
  moveThreshold: 10
});

const clickHandler = new ModernClickHandler();

// Modern SVG Components
const SVG_ICONS = {
  minus: `
<svg viewBox="0 0 24 24" aria-hidden="true">
  <path opacity="0.5"
        d="M2 12C2 7.28595 2 4.92893 3.46447 3.46447
           C4.92893 2 7.28595 2 12 2
           C16.714 2 19.0711 2 20.5355 3.46447
           C22 4.92893 22 7.28595 22 12
           C22 16.714 22 19.0711 20.5355 20.5355
           C19.0711 22 16.714 22 12 22
           C7.28595 22 4.92893 22 3.46447 20.5355
           C2 19.0711 2 16.714 2 12Z"
        fill="none"
        stroke="currentColor"
        stroke-width="1.5"/>
  <path d="M15 12H9"
        stroke="currentColor"
        stroke-width="1.5"
        stroke-linecap="round"/>
</svg>
`,

  plus: `
<svg viewBox="0 0 24 24" aria-hidden="true">
  <path opacity="0.5"
        d="M2 12C2 7.28595 2 4.92893 3.46447 3.46447
           C4.92893 2 7.28595 2 12 2
           C16.714 2 19.0711 2 20.5355 3.46447
           C22 4.92893 22 7.28595 22 12
           C22 16.714 22 19.0711 20.5355 20.5355
           C19.0711 22 16.714 22 12 22
           C7.28595 22 4.92893 22 3.46447 20.5355
           C2 19.0711 2 16.714 2 12Z"
        fill="none"
        stroke="currentColor"
        stroke-width="1.5"/>
  <path d="M12 9V15M9 12H15"
        stroke="currentColor"
        stroke-width="1.5"
        stroke-linecap="round"/>
</svg>
`
};

/**
 * Modern Data Management System
 */
class DataManager {
  constructor() {
    this.save = Utils.debounce(this._save.bind(this), 100);
    this.listeners = new Map();
  }

  _save(key, value) {
    return Utils.storage.set(key, value);
  }

  save(key, value) {
    this._save(key, value);
    this.notifyListeners(key, value);
  }

  load(key, fallback) {
    return Utils.storage.get(key, fallback);
  }

  remove(key) {
    Utils.storage.remove(key);
    this.notifyListeners(key, null);
  }

  subscribe(key, callback) {
    if (!this.listeners.has(key)) {
      this.listeners.set(key, new Set());
    }
    this.listeners.get(key).add(callback);
    
    // Return unsubscribe function
    return () => {
      const callbacks = this.listeners.get(key);
      if (callbacks) {
        callbacks.delete(callback);
      }
    };
  }

  notifyListeners(key, value) {
    const callbacks = this.listeners.get(key);
    if (callbacks) {
      callbacks.forEach(callback => {
        try {
          callback(value, key);
        } catch (error) {
          console.error('Error in data listener:', error);
        }
      });
    }
  }

  clear() {
    try {
      localStorage.clear();
      // Notify all listeners
      this.listeners.forEach((callbacks, key) => {
        callbacks.forEach(callback => {
          try {
            callback(null, key);
          } catch (error) {
            console.error('Error in clear listener:', error);
          }
        });
      });
      return true;
    } catch (error) {
      console.error('Failed to clear storage:', error);
      return false;
    }
  }
}

const dataManager = new DataManager();

/**
 * Modern Stats Calculation System
 */
class StatsCalculator {
  static calculateLevel() {
    const endurance = Number(dataManager.load('Endurance', 0)) || 0;
    const skill = Number(dataManager.load('Skill', 0)) || 0;
    const strength = Number(dataManager.load('Strength', 0)) || 0;
    const mastery = Number(dataManager.load('Mastery', 0)) || 0;
    const potency = Number(dataManager.load('Potency', 0)) || 0;
    
    return 1 + endurance + skill + strength + mastery + potency;
  }

  static calculateTinge() {
    const potency = Number(dataManager.load('Potency', 0)) || 0;
    const currentMana = Number(dataManager.load('mana', 0)) || 0;
    return potency + currentMana;
  }

  static calculateArcane() {
    const mastery = Number(dataManager.load('Mastery', 0)) || 0;
    const currentEnergy = Number(dataManager.load('energy', 0)) || 0;
    return mastery + currentEnergy;
  }

  static updateBottomStats() {
    const level = this.calculateLevel();
    const tinge = this.calculateTinge();
    const arcane = this.calculateArcane();
    
    const levelEl = document.getElementById('levelValue');
    const tingeEl = document.getElementById('tingeValue');
    const arcaneEl = document.getElementById('arcaneValue');
    
    if (levelEl) levelEl.textContent = level;
    if (tingeEl) tingeEl.textContent = tinge;
    if (arcaneEl) arcaneEl.textContent = arcane;
  }
}

/**
 * Modern Dice Roll System for Luck
 */
class DiceRollSystem {
  constructor() {
    this.cooldownTimer = null;
    this.isRolling = false;
  }

  rollLuck() {
    // Weighted random dice roll for Luck
    const options = [
      { value: -2, weight: 10 },
      { value: -1, weight: 10 },
      { value: 1, weight: 23 },
      { value: 2, weight: 23 },
      { value: 3, weight: 23 },
      { value: 4, weight: 10 },
      { value: 10, weight: 1 }
    ];

    const total = options.reduce((sum, option) => sum + option.weight, 0);
    let random = Math.random() * total;

    for (let option of options) {
      if (random < option.weight) {
        return option.value;
      }
      random -= option.weight;
    }

    return options[options.length - 1].value;
  }

  async rollAndDisplay(luckElement, labelElement, valueElement) {
    if (this.isRolling) return;
    this.isRolling = true;

    // Add visual feedback
    luckElement.classList.add('loading');
    valueElement.textContent = '...';

    // Simulate dice roll delay for better UX
    await new Promise(resolve => setTimeout(resolve, 300));

    const luckValue = this.rollLuck();
    
    // Save the luck value
    dataManager.save('Luck', luckValue);
    dataManager.save('luckShowing', true);

    // Update display
    const formattedValue = luckValue >= 0 ? `+${luckValue}` : `${luckValue}`;
    valueElement.textContent = formattedValue;
    labelElement.textContent = 'Luck';
    luckElement.classList.remove('cooling');
    luckElement.classList.remove('loading');

    // Start cooldown
    this.startCooldown(luckElement, labelElement, 60); // 60 second cooldown

    this.isRolling = false;
  }

  startCooldown(luckElement, labelElement, seconds) {
    const cooldownEnd = Date.now() + (seconds * 1000);
    dataManager.save('luckCooldownUntil', cooldownEnd);

    this.updateCooldownDisplay(luckElement, labelElement, cooldownEnd);

    if (this.cooldownTimer) {
      clearInterval(this.cooldownTimer);
    }

    this.cooldownTimer = setInterval(() => {
      this.updateCooldownDisplay(luckElement, labelElement, cooldownEnd);
    }, 1000);
  }

  updateCooldownDisplay(luckElement, labelElement, cooldownEnd) {
    const now = Date.now();
    const remaining = Math.ceil((cooldownEnd - now) / 1000);

    if (remaining <= 0) {
      // Cooldown finished
      if (this.cooldownTimer) {
        clearInterval(this.cooldownTimer);
        this.cooldownTimer = null;
      }
      dataManager.remove('luckCooldownUntil');
      luckElement.classList.remove('cooling');
      return;
    }

    // Update display
    luckElement.classList.add('cooling');
    labelElement.textContent = `Luck (${remaining}s)`;
  }

  restoreCooldown(luckElement, labelElement) {
    const cooldownEnd = dataManager.load('luckCooldownUntil', null);
    if (cooldownEnd && cooldownEnd > Date.now()) {
      this.startCooldown(luckElement, labelElement, Math.ceil((cooldownEnd - Date.now()) / 1000));
    }
  }
}

const diceRollSystem = new DiceRollSystem();

/**
 * Modern UI Components
 */
class ModernUI {
  static createBarIcon(barKey, barLabel) {
    const iconContainer = document.createElement('div');
    iconContainer.className = `bar-icon bar-icon--${barKey}`;
    iconContainer.setAttribute('role', 'img');
    iconContainer.setAttribute('aria-label', `${barLabel} icon`);
    
    const img = document.createElement('img');
    img.alt = `${barLabel} icon`;
    img.decoding = 'async';
    img.loading = 'lazy';
    
    const iconPaths = {
      life: '../icons/life1.png',
      mana: '../icons/mana1.png',
      stamina: '../icons/stamina1.png',
      energy: '../icons/energy1.png',
      empower: '../icons/empower1.png',
      coalesce: '../icons/crys.svg'
    };
    
    img.src = iconPaths[barKey] || iconPaths.life;
    iconContainer.appendChild(img);
    
    return iconContainer;
  }

  static flashElement(element) {
    element.style.transition = 'box-shadow .18s ease, transform .12s ease';
    element.style.transform = 'translateY(-0.125rem)';
    element.style.boxShadow = '0 0.875rem 2.25rem rgba(0,0,0,0.55)';
    setTimeout(() => {
      element.style.transform = '';
      element.style.boxShadow = '';
    }, 160);
  }

  static updateButtonStates(button, isDisabled) {
    button.disabled = isDisabled;
    button.setAttribute('aria-disabled', isDisabled.toString());
  }
}

/**
 * Modern Application Controller
 */
class PlayerApp {
  constructor() {
    this.barUpdateFunctions = {};
    this.init();
  }

  init() {
    this.setupBars();
    this.setupAttributes();
    this.setupPlayerName();
    this.setupResetButton();
    this.setupRelationshipSystem();
    this.updateBottomStats();
  }

  setupBars() {
    const barsConfig = [
      { key: 'life', label: 'Life', dotClass: 'dot-life', min: -10, max: 30, default: 3, dynamic: true },
      { key: 'mana', label: 'Mana', dotClass: 'dot-mana', min: -1, max: 30, default: 0, dynamic: true },
      { key: 'stamina', label: 'Stamina', dotClass: 'dot-stamina', min: -3, max: 9, default: 1, dynamic: true },
      { key: 'energy', label: 'Energy', dotClass: 'dot-energy', min: -1, max: 30, default: 0, dynamic: true },
      { key: 'empower', label: 'Empower', dotClass: 'dot-empower', min: 0, max: 12, default: 0, dynamic: false },
      { key: 'coalesce', label: 'Coalesce', dotClass: 'dot-coalesce', min: 0, max: 12, default: 3, dynamic: false }
    ];

    const barsContainer = document.getElementById('bars');

    barsConfig.forEach(cfg => {
      let value = dataManager.load(cfg.key, cfg.default);
      value = Math.max(cfg.min, Math.min(cfg.max, value));
      
      const card = document.createElement('div');
      card.className = 'bar-card';
      card.dataset.key = cfg.key;
      card.setAttribute('tabindex', '0');
      card.setAttribute('role', 'group');
      card.setAttribute('aria-label', `${cfg.label} control`);

      const left = document.createElement('div');
      left.className = 'bar-left';
      
      const dot = document.createElement('div');
      dot.className = `bar-dot ${cfg.dotClass}`;
      
      const label = document.createElement('div');
      label.className = 'bar-label';
      label.textContent = cfg.label;

      left.appendChild(dot);
      left.appendChild(label);

      const icon = ModernUI.createBarIcon(cfg.key, cfg.label);
      dot.appendChild(icon);

      const controls = document.createElement('div');
      controls.className = 'bar-controls';

      const valSpan = document.createElement('div');
      valSpan.className = 'bar-value';
      
      const minus = document.createElement('button');
      minus.className = 'btn btn-icon';
      minus.innerHTML = SVG_ICONS.minus;
      minus.setAttribute('aria-label', `Decrease ${cfg.label}`);

      const plus = document.createElement('button');
      plus.className = 'btn btn-icon';
      plus.innerHTML = SVG_ICONS.plus;
      plus.setAttribute('aria-label', `Increase ${cfg.label}`);

      const getCurrentMax = () => {
        if (cfg.dynamic) {
          return this.calculateLimits()[cfg.key];
        }
        return cfg.max;
      };

      const updateDisplay = () => {
        if (cfg.dynamic) {
          const currentMax = getCurrentMax();
          valSpan.textContent = `${value} / ${currentMax}`;
        } else {
          valSpan.textContent = String(value);
        }
      };

      const updateButtonStates = () => {
        const currentMax = getCurrentMax();
        ModernUI.updateButtonStates(minus, value <= cfg.min);
        ModernUI.updateButtonStates(plus, value >= currentMax);
      };

      const updateBar = () => {
        const currentMax = getCurrentMax();
        if (value > currentMax) {
          value = currentMax;
          dataManager.save(cfg.key, value);
        }
        updateDisplay();
        updateButtonStates();
      };

      minus.addEventListener('click', () => {
        const newValue = value - 1;
        if (newValue >= cfg.min) {
          value = newValue;
          updateDisplay();
          dataManager.save(cfg.key, value);
          updateButtonStates();
          
          if (cfg.key === 'mana' || cfg.key === 'energy') {
            this.updateBottomStats();
          }
          
          ModernUI.flashElement(card);
        }
      });

      plus.addEventListener('click', () => {
        const currentMax = getCurrentMax();
        const newValue = value + 1;
        if (newValue <= currentMax) {
          value = newValue;
          updateDisplay();
          dataManager.save(cfg.key, value);
          updateButtonStates();
          
          if (cfg.key === 'mana' || cfg.key === 'energy') {
            this.updateBottomStats();
          }
          
          ModernUI.flashElement(card);
        }
      });

      updateDisplay();
      updateButtonStates();

      controls.appendChild(minus);
      controls.appendChild(valSpan);
      controls.appendChild(plus);

      card.appendChild(left);
      card.appendChild(controls);
      barsContainer.appendChild(card);

      // Store update function for dynamic bars
      if (cfg.dynamic) {
        this.barUpdateFunctions[cfg.key] = () => {
          updateBar();
          if (cfg.key === 'mana' || cfg.key === 'energy') {
            this.updateBottomStats();
          }
        };
      }
    });
  }

  calculateLimits() {
    const limits = {
      life: 3,
      stamina: 1,
      mana: 3,
      energy: 2
    };

    const endurance = Number(dataManager.load('Endurance', 0)) || 0;
    const skill = Number(dataManager.load('Skill', 0)) || 0;
    const strength = Number(dataManager.load('Strength', 0)) || 0;
    const potency = Number(dataManager.load('Potency', 0)) || 0;
    const mastery = Number(dataManager.load('Mastery', 0)) || 0;

    const enduranceBonuses = [
      null,
      { life: 2, stamina: 1, mana: 0, energy: 0 },
      { life: 2, stamina: 1, mana: 0, energy: 0 },
      { life: 2, stamina: 1, mana: 0, energy: 0 },
      { life: 2, stamina: 1, mana: 0, energy: 0 },
      { life: 2, stamina: 1, mana: 0, energy: 0 },
      { life: 2, stamina: 1, mana: 0, energy: 0 },
      { life: 1, stamina: 0, mana: 0, energy: 0 },
      { life: 1, stamina: 0, mana: 0, energy: 0 },
      { life: 1, stamina: 0, mana: 0, energy: 0 },
    ];

    const skillBonuses = [
      null,
      { life: 1, stamina: 0, mana: 0, energy: 0 },
      { life: 1, stamina: 1, mana: 0, energy: 0 },
      { life: 1, stamina: 0, mana: 0, energy: 0 },
      { life: 1, stamina: 0, mana: 0, energy: 0 },
      { life: 1, stamina: 0, mana: 0, energy: 0 },
      { life: 1, stamina: 0, mana: 0, energy: 0 },
      { life: 0, stamina: 0, mana: 0, energy: 0 },
      { life: 0, stamina: 0, mana: 0, energy: 0 },
      { life: 0, stamina: 0, mana: 0, energy: 0 },
    ];

    const strengthBonuses = [
      null,
      { life: 1, stamina: 0, mana: 0, energy: 0 },
      { life: 1, stamina: 0, mana: 0, energy: 0 },
      { life: 1, stamina: 0, mana: 0, energy: 0 },
      { life: 1, stamina: 0, mana: 0, energy: 0 },
      { life: 1, stamina: 1, mana: 0, energy: 0 },
      { life: 1, stamina: 0, mana: 0, energy: 0 },
      { life: 0, stamina: 0, mana: 0, energy: 0 },
      { life: 0, stamina: 0, mana: 0, energy: 0 },
      { life: 0, stamina: 0, mana: 0, energy: 0 },
    ];

    const potencyBonuses = [
      null,
      { life: 0, stamina: 0, mana: 3, energy: 0 },
      { life: 0, stamina: 0, mana: 2, energy: 1 },
      { life: 0, stamina: 0, mana: 3, energy: 0 },
      { life: 0, stamina: 0, mana: 2, energy: 1 },
      { life: 0, stamina: 0, mana: 3, energy: 0 },
      { life: 0, stamina: 0, mana: 3, energy: 0 },
      { life: 0, stamina: 0, mana: 2, energy: 0 },
      { life: 0, stamina: 0, mana: 2, energy: 0 },
      { life: 0, stamina: 0, mana: 3, energy: 0 },
    ];

    const masteryBonuses = [
      null,
      { life: 0, stamina: 0, mana: 1, energy: 2 },
      { life: 0, stamina: 0, mana: 0, energy: 3 },
      { life: 0, stamina: 0, mana: 1, energy: 3 },
      { life: 0, stamina: 0, mana: 0, energy: 3 },
      { life: 0, stamina: 0, mana: 0, energy: 2 },
      { life: 0, stamina: 0, mana: 0, energy: 2 },
      { life: 0, stamina: 0, mana: 0, energy: 2 },
      { life: 0, stamina: 0, mana: 0, energy: 2 },
      { life: 0, stamina: 0, mana: 0, energy: 2 },
    ];

    const sumBonuses = (bonusTable, rank) => {
      let total = { life: 0, stamina: 0, mana: 0, energy: 0 };
      for (let i = 1; i <= rank && i < bonusTable.length; i++) {
        if (bonusTable[i]) {
          total.life += bonusTable[i].life;
          total.stamina += bonusTable[i].stamina;
          total.mana += bonusTable[i].mana;
          total.energy += bonusTable[i].energy;
        }
      }
      return total;
    };

    const endBonus = sumBonuses(enduranceBonuses, endurance);
    const skillBonus = sumBonuses(skillBonuses, skill);
    const strBonus = sumBonuses(strengthBonuses, strength);
    const potBonus = sumBonuses(potencyBonuses, potency);
    const mastBonus = sumBonuses(masteryBonuses, mastery);

    limits.life += endBonus.life + skillBonus.life + strBonus.life + potBonus.life + mastBonus.life;
    limits.stamina += endBonus.stamina + skillBonus.stamina + strBonus.stamina + potBonus.stamina + mastBonus.stamina;
    limits.mana += endBonus.mana + skillBonus.mana + strBonus.mana + potBonus.mana + mastBonus.mana;
    limits.energy += endBonus.energy + skillBonus.energy + strBonus.energy + potBonus.energy + mastBonus.energy;

    return limits;
  }

  updateAllBars() {
    Object.values(this.barUpdateFunctions).forEach(updateFn => updateFn());
  }

  updateBottomStats() {
    StatsCalculator.updateBottomStats();
  }

  setupAttributes() {
    const attrConfig = ["Endurance", "Skill", "Strength", "Potency", "Mastery", "Luck"];
    const attrsContainer = document.getElementById('attributes');

    const limitAffectingAttrs = ["Endurance", "Skill", "Strength", "Potency", "Mastery"];

    attrConfig.forEach(name => {
      const stored = dataManager.load(name, name === 'Luck' ? null : 0);
      const finalStored = name !== 'Luck' ? Number(stored) || 0 : stored;

      const card = document.createElement('div');
      card.className = 'attr';
      card.dataset.name = name;

      const label = document.createElement('div');
      label.className = 'attr-label';
      label.textContent = name;

      const valWrap = document.createElement('div');
      valWrap.className = 'attr-value-wrap';

      const icon = document.createElement('img');
      icon.className = 'attr-icon';

      const STAT_ICONS = {
        Endurance: '../icons/heart-shield.png',
        Skill: '../icons/skl.png',
        Strength: '../icons/str.png',
        Potency: '../icons/potency8.png',
        Mastery: '../icons/mastery4.png'
      };

      if (STAT_ICONS[name]) {
        icon.src = STAT_ICONS[name];
        icon.alt = `${name} icon`;
      } else {
        icon.style.display = 'none';
      }

      const val = document.createElement('span');
      val.className = 'attr-val';
      val.textContent = name === 'Luck' ? '--' : finalStored;

      valWrap.appendChild(icon);
      valWrap.appendChild(val);

      card.appendChild(label);
      card.appendChild(valWrap);
      attrsContainer.appendChild(card);

      if (name === 'Luck') {
        // Special Luck attribute handling
        card.classList.add('luck');
        
        const rollLuck = () => {
          const cooldownUntil = dataManager.load('luckCooldownUntil', null);
          if (cooldownUntil && cooldownUntil > Date.now()) {
            const remaining = Math.ceil((cooldownUntil - Date.now()) / 1000);
            label.textContent = `Luck (${remaining}s)`;
            return;
          }
          
          diceRollSystem.rollAndDisplay(card, label, val);
        };

        // Use click handler instead of touch manager for Luck
        clickHandler.attach(card, rollLuck, {
          ariaLabel: 'Click to roll luck dice'
        });

        // Restore cooldown if exists
        diceRollSystem.restoreCooldown(card, label);

      } else {
        // Regular attributes with press-and-hold
        let valNum = finalStored;
        let lockout = false;

        const incrementAttribute = () => {
          if (lockout) return;

          valNum = (valNum + 1) % 10;
          val.textContent = String(valNum);
          dataManager.save(name, valNum);

          if (limitAffectingAttrs.includes(name)) {
            this.updateAllBars();
            this.updateBottomStats();
          }

          card.classList.add('pulse');
          setTimeout(() => card.classList.remove('pulse'), 420);

          lockout = true;
          setTimeout(() => { lockout = false; }, 3000);
        };

        touchManager.attach(card, incrementAttribute, {
          ariaLabel: `Press and hold to increase ${name}`,
          progressColor: '#D4AF37',
          flashColor: '#D4AF37'
        });
      }
    });
  }

  setupPlayerName() {
    const playerNameInput = document.getElementById('playerName');
    const existingName = dataManager.load('playerName', '');
    
    if (existingName) {
      playerNameInput.value = existingName;
    }

    const savePlayerName = Utils.debounce(() => {
      const nm = playerNameInput.value.trim();
      dataManager.save('playerName', nm);
    }, 300);

    playerNameInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        savePlayerName();
        playerNameInput.blur();
      }
    });

    playerNameInput.addEventListener('input', savePlayerName);
    playerNameInput.addEventListener('blur', savePlayerName);
  }

  setupResetButton() {
    const resetBtn = document.getElementById('resetBtn');
    resetBtn.addEventListener('click', () => {
      if (confirm('Are you sure you want to RESET ALL DATA?')) {
        dataManager.clear();
        location.reload();
      }
    });
  }

  setupRelationshipSystem() {
    // Placeholder for relationship system
    // This would be implemented similarly with modern standards
  }
}

// Initialize the application
document.addEventListener('DOMContentLoaded', () => {
  new PlayerApp();
});

// Handle page visibility changes for better performance
document.addEventListener('visibilitychange', () => {
  if (document.hidden) {
    // Pause any animations or timers when page is hidden
  } else {
    // Resume animations when page becomes visible
  }
});

// Handle service worker registration for PWA capabilities
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    // navigator.serviceWorker.register('/sw.js')
    //   .then(registration => console.log('SW registered'))
    //   .catch(error => console.log('SW registration failed'));
  });
}

</script>
</body>
</html>