<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Player</title>

<style>
  :root{
    /* Base font size for rem calculations */
    font-size: 1rem;
    
    --bg:#121212;
    --card:#1f1f1f;
    --muted:#9aa3ad;
    --accent-purple: rgba(106,27,154,0.22);
    --gold: #D4AF37;
    --blue-cool:#66ccff;
    --glass: rgba(255,255,255,0.04);
    --heart-white: #ffffff;
    --heart-blue: #4da6ff;
    --heart-purple: #9b59b6;
    --heart-red: #ff8fa3;
    --scarlet-pink: #ff8fa3;
    
    /* Animation timing variables for consistency */
    --fade-in-duration: 0.3s;
    --fade-out-duration: 2s;
    --icon-linger-duration: 3s;
    --easing-smooth: cubic-bezier(0.4, 0, 0.2, 1);
    --easing-bounce: cubic-bezier(0.68, -0.55, 0.265, 1.55);
    
    /* Professional press-and-hold timing */
    --hold-duration: 2.5s; /* 2.5 seconds as requested */
    --hold-easing: cubic-bezier(0.25, 0.46, 0.45, 0.94);
    /* Note: Stats only increase when hold completes, not on click */
    --progress-color: #ffffff; /* White for regular attributes */
    --progress-bg: rgba(255, 255, 255, 0.2);
    --flash-color: #ffffff; /* White flash */
  }

  html,body{height:100%;margin:0;}
  body{
    margin:0;
    min-height:100%;
    font-family: "Inter", "Segoe UI", Arial, sans-serif;
    background: linear-gradient(180deg,#0f0f12 0%, #141417 60%);
    color:#e9eef6;
    -webkit-font-smoothing:antialiased;
    -moz-osx-font-smoothing:grayscale;
  }

  .wrap{
    max-width:56.25rem; /* 900px */
    margin:0.875rem auto;
    padding:1rem;
  }

  /* Player name */
  #playerName{
    width:100%;
    display:block;
    font-size:2.0rem;
    text-align:center;
    background:transparent;
    color: #fff;
    border: 0;
    outline:0;
    padding:0.3rem 0.3rem;
    margin-top:1.5rem;
    margin-bottom:0.5rem;
  }
  #playerName::placeholder{ color: rgba(255,255,255,0.35); }

  /* ---------- Bars layout: grid 2 cols on wide, 1 col + reorder on small ---------- */
  .bars {
    display:grid;
    grid-template-columns: repeat(2, minmax(13.75rem, 1fr)); /* 220px */
    gap:1.2rem; /* 20px */
    margin-bottom:1rem; /* 16px */
  }

  @media (max-width: 45.1rem) { /* 720px */
    .bars { grid-template-columns: 1fr; }

    .bar-card[data-key="life"]     { order: 1; }
    .bar-card[data-key="stamina"]  { order: 2; }
    .bar-card[data-key="empower"]  { order: 3; }
    .bar-card[data-key="mana"]     { order: 4; }
    .bar-card[data-key="energy"]   { order: 5; }
    .bar-card[data-key="coalesce"] { order: 6; }
  }

  @media (min-width: 45rem) { /* 721px */
    .bar-card { order: initial; }
  }

  .bar-card{
    background: linear-gradient(180deg, rgba(100,100,100,0.03), rgba(200,200,200,0.07));
    border-radius:1.25rem; /* 20px */
    padding:0.625rem 0.75rem; /* 10px 12px */
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:1.25rem; /* 20px */
    box-shadow: 0 0.375rem 1.125rem rgba(0,0,0,0.6); /* 6px 18px */
    transition: transform .2s ease, box-shadow .25s ease;
    position: relative;
    overflow: hidden;
  }
  .bar-card:hover{ transform: translateY(-0.125rem); box-shadow: 0 1.25rem 1.875rem rgba(0,0,0,0.7); }

  .bar-left{
    display:flex;
    align-items:center;
    gap:0.875rem; /* 14px */
    min-width: 0;
    position: relative;
  }

  .bar-dot{
    width: 2.2rem; /* 35px */
    height: 2.2rem; /* 35px */
    border-radius:50%;
    box-shadow: 0 0.125rem 0.375rem rgba(0,0,0,0.6), inset 0 -0.0625rem 0 rgba(255,255,255,0.05); /* 2px 6px */
    flex: 0 0 auto;
    position: relative;
  }
  .dot-life{ background: linear-gradient(180deg,#5fd08f,#2fb96b); }
  .dot-stamina{ background: linear-gradient(180deg,#6fb8ff,#2b74ff); }
  .dot-mana{ background: linear-gradient(180deg,#ffc46b,#ff9a2b); }
  .dot-energy{ background: linear-gradient(180deg,#6ff0ff,#13b6ff); }
  .dot-empower{ background: linear-gradient(180deg,#ff4d4d,#DC143C); }
  .dot-coalesce{ background: linear-gradient(180deg,#f5f7fa,#d9dde6); border:0.0625rem solid rgba(255,255,255,0.06); }

  /* ===== ICON OVERLAY SYSTEM ===== */
  
  .bar-icon {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0.85);
    width: 2.3rem; /* 37px */
    height: 2.3rem; /* 37px */
    opacity: 0;
    pointer-events: none;
    z-index: 10;
    filter: drop-shadow(0 0.25rem 0.5rem rgba(0, 0, 0, 0.3));
    
    will-change: opacity, transform;
    backface-visibility: hidden;
    
    transition: 
      opacity var(--fade-in-duration) var(--easing-smooth),
      transform var(--fade-in-duration) var(--easing-bounce);
  }

  .bar-icon.visible {
    opacity: 1;
    transform: translate(-50%, -50%) scale(1);
  }

  .bar-icon.fading {
    opacity: 0;
    transform: translate(-50%, -50%) scale(0.8);
    transition: 
      opacity var(--fade-out-duration) var(--easing-smooth),
      transform var(--fade-out-duration) var(--easing-smooth);
  }

  .bar-icon img {
    width: 100%;
    height: 100%;
    object-fit: contain;
    image-rendering: -webkit-optimize-contrast;
    image-rendering: crisp-edges;
    filter: drop-shadow(0 0.125rem 0.25rem rgba(0, 0, 0, 0.2));
    transition: filter var(--fade-in-duration) var(--easing-smooth);
  }

  .bar-card:hover .bar-icon img {
    filter: drop-shadow(0 0.25rem 0.5rem rgba(0, 0, 0, 0.3)) brightness(1.1);
  }

  .bar-label{ font-weight:600; font-size:1.38rem; color:#f1f5fb; white-space:nowrap; }
  .bar-controls{ display:flex; align-items:center; gap:0.1rem; padding-right: 0.125rem; }

  .bar-value{
    width:5rem; /* 80px */
    text-align:center;
    font-weight:700;
    font-size:1.10rem;
    color:#ffffff;
    font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
  }

  .btn {
    -webkit-appearance:none;
    appearance:none;
    border:0;
    background: rgba(255,255,255,0.09);
    color: #fff;
    padding:0.375rem 0.625rem; /* 6px 10px */
    border-radius:0.5rem; /* 8px */
    cursor:pointer;
    font-weight:700;
    transition: transform .12s ease, background .12s ease, box-shadow .12s ease;
  }
  .btn:active{ transform: scale(.97); }
  .btn:focus{ outline:none; box-shadow:0 0 0 0.1875rem rgba(102,204,255,0.12); }
  .btn:disabled{ opacity: 0.3; cursor: not-allowed; }
  .btn:hover { background: #ff00ff; }
  .btn-icon:hover { background: rgba(255,255,255,0.11); }

  .btn-icon {
    padding: 0.125rem;
    display: inline-flex;
    align-items: center;
    justify-content: center;
  }

  .btn-icon svg {
    width: 2rem;
    height: 2rem;
    color: white;
    transition: transform 0.2s ease, color 0.2s ease;
  }

  .btn-icon:hover svg {
    transform: scale(1.10);
    color: #ff00ff;
  }

  .btn-icon:disabled svg {
    opacity: 0.6;
  }

  /* ========= SIMPLIFIED ATTRIBUTE PRESS-AND-HOLD STYLES ========= */
  
  .attributes{
    display:grid;
    grid-template-columns: repeat(auto-fit, minmax(4.6rem, 1fr)); /* 120px */
    gap:1rem; /* 15px */
    margin-top:0.5rem; /* 20px */
    
    /* 2025 Performance Optimization: CSS Containment */
    contain: layout style;
  }
  
  /* 2025 Container Queries for Enhanced Responsiveness */
  @container (max-width: 48rem) {
    .attributes {
      grid-template-columns: repeat(3, 1fr);
      gap: 0.875rem;
    }
  }
  
  @container (max-width: 32rem) {
    .attributes {
      grid-template-columns: repeat(2, 1fr);
      gap: 0.75rem;
    }
  }

  .attr{
    background: linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0.02));
    border-radius:0.75rem; /* 12px */
    padding:1rem; /* 16px */
    display:flex;
    flex-direction:column;
    align-items:center;
    justify-content:center;
    gap:0.5rem; /* 8px */
    cursor:pointer;
    transition: box-shadow .16s ease, border-color .16s ease;
    user-select:none;
    
    /* Professional touch target sizing */
    min-height: 1rem; /* 48px */
    min-width: 1rem;  /* 48px */
    
    touch-action: manipulation;
    
    position: relative;
    overflow: visible;
    
    /* 2025 Performance: GPU Acceleration for animations */
    will-change: transform, box-shadow;
    backface-visibility: hidden;
    transform-style: preserve-3d;
  }
  
  /* Hover state - desktop only (purple shadow) */
  .attr:hover:not(.mobile-only) {
    box-shadow: 0 0 0.75rem rgba(106, 27, 154, 0.6);
  }
  
  /* Press-and-hold visual states - progressive shadow animation */
  .attr.holding {
    /* Start with white shadow that grows and brightens during hold */
    box-shadow: 0 0 1rem rgba(255, 255, 255, 0.5);
    /* Progressive shadow animation during hold */
    animation: progressiveShadow var(--hold-duration) ease-out forwards;
  }
  
  /* Success flash animation - gold flash at completion */
  .attr.flash {
    animation: goldFlash 1.0s ease-out forwards;
  }

  .attr .attr-label{ 
    font-weight:700; 
    color:#f4f6fb; 
    white-space: nowrap;
    font-size: 0.8rem;
  }

  .attr .attr-val{ 
    font-weight:800; 
    font-size:1.05rem; 
    color:#eaeef8; 
    font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
  }

  /* ========= CLOCK-STYLE PROGRESS RING ANIMATION ========= */
  
  .progress-ring {
    position: absolute;
    top: -0.25rem;
    left: -0.25rem;
    right: -0.25rem;
    bottom: -0.25rem;
    border-radius: 0.75rem;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.25s ease;
    /* 2025 Performance: Optimize SVG rendering */
    transform: translateZ(0);
    backface-visibility: hidden;
  }
  
  .attr.holding .progress-ring {
    opacity: 1;
  }
  
  .progress-ring svg {
    width: 100%;
    height: 100%;
    border-radius: 0.75rem;
  }
  
  .progress-ring circle {
    fill: none;
    stroke-width: 0.25rem; /* 3px */
    stroke-linecap: round;
    transform-origin: center;
    /* Start at 12 o'clock position */
    transform: rotate(-90deg);
  }
  
  .progress-ring .progress-bg {
    stroke: var(--progress-bg);
  }
  
  .progress-ring .progress-bar {
    stroke: var(--progress-color);
    /* Will be set dynamically via JavaScript */
    stroke-dasharray: 251.327; /* Default - will be calculated */
    stroke-dashoffset: 251.327; /* Default - will be calculated */
    animation: none;
  }
  
  .attr.holding .progress-bar {
    animation: fillProgress var(--hold-duration) var(--hold-easing) forwards;
  }
  
  /* Clock-style animation: fills from 0° to 360° clockwise */
  @keyframes fillProgress {
    0% {
      stroke-dashoffset: var(--circumference, 251.327); /* Full circumference - no progress */
    }
    100% {
      stroke-dashoffset: 0; /* No offset - full circle filled */
    }
  }

  /* Progressive shadow during hold: white → larger/brighter white */
  @keyframes progressiveShadow {
    0% { box-shadow: 0 0 1rem rgba(255, 255, 255, 0.4); /* Starting white */ }
    50% { box-shadow: 0 0 1.5rem rgba(255, 255, 255, 0.7); /* Growing brighter */  }
    100% { box-shadow: 0 0 2rem rgba(255, 255, 255, 0.9); /* Largest and brightest */  }
  }
  
  /* Flash animation at completion: gold flash */
  @keyframes goldFlash {
    0% { box-shadow: 0 0 2rem rgba(255, 255, 255, 0.9); /* From bright white */ }
    50% { box-shadow: 0 0 2.5rem rgba(255, 215, 0, 1.0); /* Gold flash */ }
    100% { box-shadow: 0 0 1.5rem rgba(255, 215, 0, 0.6); /* Gold fade */ }
  }
  
  /* Apply the gold flash animation for completion */
  .pulse { animation: goldFlash 0.6s ease-out forwards; }

  .attr.luck{
    border: 0.0625rem solid var(--gold);
    box-shadow: 0 0.375rem 1.5rem rgba(212,175,55,0.12), inset 0 0.0625rem 0 rgba(255,255,255,0.03);
    /* 2025 Enhancement: Set gold colors for progress ring */
    --progress-color: var(--gold);
    --progress-bg: rgba(212, 175, 55, 0.2);
    --flash-color: var(--gold);
    /* 2025 Enhancement: Subtle gold shimmer effect */
    background: linear-gradient(135deg, rgba(212,175,55,0.05), rgba(212,175,55,0.02));
  }
  
  /* 2025 Enhancement: Special hover effect for luck */
  .attr.luck:hover:not(.cooling) {
    box-shadow: 0 0.5rem 2rem rgba(212,175,55,0.25), inset 0 0.0625rem 0 rgba(255,255,255,0.05);
    border-color: rgba(212,175,55,0.8);
  }
  .attr.luck.cooling{ 
    border: none; /* 2025 Fix: No border during cooldown */
    box-shadow: 0 0.375rem 1rem rgba(255, 255, 255, 0.15), inset 0 0.0625rem 0 rgba(255,255,255,0.02);
    /* 2025 Enhancement: Subtle white shadow during cooldown */
    background: linear-gradient(135deg, rgba(212,175,55,0.02), rgba(212,175,55,0.01));
  }
  .attr.luck.holding {
    border-color: var(--gold);
    /* 2025 Enhancement: Gold-themed progress with luxurious glow */
    box-shadow: 0 0 1.5rem rgba(212, 175, 55, 0.6);
    animation: progressiveShadowLuck var(--hold-duration) ease-out forwards;
  }
  
  /* 2025 Enhancement: Gold-themed progressive shadow animation for luck */
  @keyframes progressiveShadowLuck {
    0% { 
      box-shadow: 0 0 1.5rem rgba(212, 175, 55, 0.6);
      transform: scale(1.02);
    }
    50% { 
      box-shadow: 0 0 2rem rgba(212, 175, 55, 0.8);
      transform: scale(1.04);
    }
    100% { 
      box-shadow: 0 0 2.5rem rgba(212, 175, 55, 1.0);
      transform: scale(1.06);
    }
  }
  .attr.luck.flash {
    border-color: var(--gold);
    box-shadow: 0 0 1.35rem var(--gold);
  }
  .luck-timer {
  display: inline-block;
  width: 4ch; /* fixed width for '(30s)' */
  }

  .muted{ color: rgba(255,255,255,0.54); font-size:0.88rem; }
  .center{ text-align:center; }

  @media(max-width:28rem){ /* >440px */
    .bar-card{ padding:0.35rem; }
    .bar-controls{ padding-right: 0.5rem; }
    .attributes{ gap:1rem; margin-top:2rem; grid-template-columns: repeat(3, 1fr); }
      #playerName{ margin-top:2.0rem; margin-bottom:0.2rem; }
    .attr {
      min-height: 1rem;
      min-width: 1rem;
    }
    
    .attr .attr-label {
      font-size: 0.8rem;
    }
    
    .attr .attr-val {
      font-size: 1rem;
    }
  }

  /* Mobile-specific touch handling */
  @media (pointer: coarse) {
    .attr {
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
      user-select: none;
    }
    
    .attr.mobile-only:hover {
      box-shadow: 0 0 0.5rem rgba(140, 50, 230, 0.6);
    }
  }

  #resetBtn {
    position: fixed;
    top: 0.6rem;
    left: 0.6rem;
    background: #1f1f1f;
    color: white;
    border: none;
    border-radius: 0.4rem;
    padding: 0.4rem 0.8rem;
    font-size: 1rem;
    font-weight: bold;
    cursor: pointer;
    z-index: 1000;
    transition: background 0.25s;
  }
  #resetBtn:hover { background: #ff4d4d; }

  /* Heart Button - Top Right */
  #heartBtn {
    position: fixed;
    top: 0.6rem;
    right: 1.6rem;
    width: 3rem;
    height: 3rem;
    background: transparent;
    border: 0.1875rem solid white;
    border-radius: 0.5rem;
    cursor: pointer;
    z-index: 1001;
    transition: all 0.4s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0;
  }
  #heartBtn svg {
    width: 2rem;
    height: 2rem;
    fill: transparent;
    stroke: white;
    stroke-width: 2;
    transition: all 0.5s ease;
  }
  #heartBtn.active {
    background: var(--scarlet-pink);
    border-color: #333;
  }
  #heartBtn.active svg {
    fill: var(--scarlet-pink);
    stroke: #333;
  }
/*  #heartBtn:hover:not(.disabled) {
    transform: scale(1.05);
  }*/
  #heartBtn.disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
#inventoryBtn {
  position: fixed;
  top: 0.6rem;
  right: 5.6rem; /* sits LEFT of heart */
  width: 3rem;
  height: 3rem;
  background: transparent;
  border: 0.1875rem solid white;
  border-radius: 0.5rem;
  cursor: pointer;
  z-index: 1001;
  transition: all 0.3s ease;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 0;
}

#inventoryBtn svg {
  width: 2rem;
  height: 2rem;
  color: white;
  transition: all 0.5s ease;
}

#inventoryBtn.active {
  background: #8b5a2b; /* rich brown */
  border-color: #2b1a0e;
}

#inventoryBtn.active svg {
  color: #d2a679; /* brighter brown */
}

/*#inventoryBtn:hover {
  transform: scale(1.05);
}*/

  /* Relationship Overlay */
  #relationshipOverlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(15, 15, 18, 0.85);
    backdrop-filter: blur(0.5rem);
    -webkit-backdrop-filter: blur(0.5rem);
    z-index: 999;
    display: none;
    overflow-y: auto;
    padding: 3.75rem 1rem 1.25rem;
  }
  #relationshipOverlay.visible {
    display: block;
  }

  .relationship-content {
    max-width: 41.25rem;
    margin: 0 auto;
  }

  .relationship-title {
    text-align: center;
    font-size: 1.8rem;
    font-weight: 700;
    margin-bottom: 1.5rem;
    color: #fff;
  }

  /* NPC Card */
  .npc-card {
    background: rgba(255, 255, 255, 0.03);
    border-radius: 1rem;
    padding: 0.5rem;
    margin-bottom: 0.5rem;
    display: flex;
    gap: 0.5rem;
    align-items: stretch;
    position: relative;
  }

  .npc-image {
      width: 9.375rem;
      height: 9.375rem;
      min-width: 9.375rem;
      background: rgba(255, 255, 255, 0.05);
      border: 0.125rem dashed rgba(255, 255, 255, 0.2);
      border-radius: 0.75rem;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s ease;
      overflow: hidden;
  }

  .npc-image:hover {
    border-color: rgba(255, 255, 255, 0.4);
    background: rgba(255, 255, 255, 0.08);
  }
  
  .npc-image svg {
    width: 4rem;
    height: 4rem;
    stroke: rgba(255, 255, 255, 0.3);
    stroke-width: 2;
    fill: none;
  }
  
  .npc-image.has-image {
    border-style: solid;
    border-color: rgba(255, 255, 255, 0.1);
  }
  
  .npc-image img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 0.625rem;
      max-width: 20rem;
      max-height: 12.5rem;
      min-width: 9.375rem;
      min-height: 9.375rem;
  }

  /* NPC Info */
  .npc-info {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }

  .npc-name-row {
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  .npc-name {
    font-size: 1.25rem;
    font-weight: 700;
    color: #fff;
    background: transparent;
    border: none;
    outline: none;
    padding: 0.25rem 0;
    padding-left: 0.5rem;
    flex: 1;
  }
  .npc-name::placeholder {
    color: rgba(255, 255, 255, 0.4);
  }

  .name-confirm-btn {
    position: absolute;
    top: 0.5rem;
    right: 0.5rem;
    width: 1.5rem;
    height: 1.5rem;
    min-width: 1.5rem;
    background: rgba(76, 175, 80, 0.2);
    border: 0.0625rem solid rgba(76, 175, 80, 0.5);
    border-radius: 0.25rem;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.2s ease;
    opacity: 0;
    pointer-events: none;
  }
  .name-confirm-btn.visible {
    opacity: 1;
    pointer-events: auto;
  }
  .name-confirm-btn:hover {
    background: rgba(76, 175, 80, 0.4);
    border-color: rgba(76, 175, 80, 0.8);
  }
  .name-confirm-btn svg {
    width: 1rem;
    height: 1rem;
    stroke: #4caf50;
    stroke-width: 3;
    fill: none;
  }

  .npc-status {
    font-size: 1rem;
    color: var(--muted);
    background: transparent;
    border: none;
    outline: none;
    padding: 0.125rem 0;
    padding-left: 0.5rem;
    width: 100%;
  }
  .npc-status::placeholder {
    color: rgba(255, 255, 255, 0.3);
  }

  /* Hearts Container */
  .npc-hearts {
    display: flex;
    gap: 0.375rem;
    margin-top: auto;
    padding-top: 0.25rem;
    flex-wrap: wrap;
  }

  .heart-icon {
    width: 3.5rem;
    height: 3.5rem;
    position: relative;
    cursor: pointer;
    transition: all 0.2s ease;
  }
  .heart-icon:hover:not(.locked) {
    transform: scale(1.1);
  }
  .heart-icon.locked {
    opacity: 0.4;
    cursor: not-allowed;
  }
  .heart-icon svg {
    width: 100%;
    height: 100%;
    stroke-width: 2;
    transition: all 0.3s ease;
  }

  /* Heart states */
  .heart-icon.empty svg {
    fill: transparent;
    stroke: rgba(255, 255, 255, 0.3);
  }
  .heart-icon.filled-white svg {
    fill: var(--heart-white);
    stroke: var(--heart-white);
  }
  .heart-icon.filled-blue svg {
    fill: var(--heart-blue);
    stroke: var(--heart-blue);
  }
  .heart-icon.filled-purple svg {
    fill: var(--heart-purple);
    stroke: var(--heart-purple);
  }
  .heart-icon.filled-red svg {
    fill: var(--heart-red);
    stroke: var(--heart-red);
  }

  /* Heart number label inside heart */
  .heart-number {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 0.85rem;
    font-weight: 700;
    color: #333;
    pointer-events: none;
    user-select: none;
  }
  .heart-icon.empty .heart-number {
    color: rgba(255, 255, 255, 0.4);
  }

  /* Pulsing animation for heart 7 */
  @keyframes heartPulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.1); }
  }
  .heart-icon.pulse-heart {
    animation: heartPulse 2s ease-in-out infinite;
  }

  /* Add NPC Button */
  .add-npc-btn {
    width: 100%;
    padding: 1rem;
    background: rgba(255, 255, 255, 0.03);
    border: 0.125rem dashed rgba(255, 255, 255, 0.25);
    border-radius: 1rem;
    color: rgba(255, 255, 255, 0.4);
    font-size: 3rem;
    font-weight: 700;
    cursor: pointer;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.6rem;
  }
  .add-npc-btn:hover {
    background: rgba(255, 255, 255, 0.07);
    border-color: rgba(255, 255, 255, 0.5);
    color: rgba(255, 255, 255, 0.6);
  }
  .add-npc-btn.disabled {
    opacity: 0.4;
    cursor: not-allowed;
    pointer-events: none;
  }
  .add-npc-btn svg {
    width: 2rem;
    height: 2rem;
    stroke: currentColor;
    stroke-width: 3;
    fill: none;
  }

  /* Delete NPC Button */
  .delete-npc-btn {
    position: absolute;
    bottom: 0.5rem;
    right: 0.5rem;
    width: 1.5rem;
    height: 1.5rem;
    background: rgba(255, 0, 0, 0.25);
    border: none;
    border-radius: 50%;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 0;
    transition: all 0.2s ease;
  }

  .npc-card:hover .delete-npc-btn {
    opacity: 1;
  }
  .delete-npc-btn:hover {
    background: rgba(255, 0, 0, 0.5);
  }
  .delete-npc-btn svg {
    width: 0.75rem;
    height: 0.75rem;
    stroke: white;
    stroke-width: 2;
    fill: none;
  }

  @media (max-width: 32rem) { /* 500px */
    .npc-card {
      flex-direction: column;
      align-items: center;
    }
    .npc-image {
      width: 9.375rem;
      height: 9.375rem;
      min-width: 9.375rem;
    }
    .npc-info {
      width: 100%;
      align-items: center;
      text-align: center;
    }
    .npc-name, .npc-status {
      text-align: center;
    }
    .npc-hearts {
      justify-content: center;
    }
  }

  @media (max-width: 40rem) { /* 640px */
    .npc-card {
      flex-direction: row;
      align-items: stretch;
      max-width: 25rem;
      padding: 0.25rem;
    }
    .npc-image {
      min-width: 9.375rem;
      width: 9.375rem;
      height: 9.375rem;
    }
    .npc-info {
      flex: 1;
      align-items: flex-start;
      padding-left: 0.5rem;
    }
    .npc-name {
      font-size: 1rem;
      text-align: left;
    }
    .npc-status {
      font-size: 0.85rem;
      text-align: left;
    }
    .npc-hearts {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 0.125rem;
      justify-content: flex-start;
      margin-top: 0.0625rem;
      padding-left: 0;
    }
    .heart-icon {
      width: 2.75rem;
      height: 2rem;
    }
    .heart-number {
      font-size: 0.7rem;
    }
    .heart-icon:nth-child(5) {
      grid-column: 1;
    }
    .heart-icon:nth-child(6) {
      grid-column: 2;
    }
    .heart-icon:nth-child(7) {
      grid-column: 3;
    }
    .name-confirm-btn {
      top: 0.375rem;
      right: 0.375rem;
    }
    .delete-npc-btn {
      bottom: 0.375rem;
      right: 0.375rem;
    }
  }

  #inventoryOverlay {
    position: fixed;
    inset: 0;
    background: rgba(15,15,18,0.85);
    backdrop-filter: blur(0.5rem);
    z-index: 999;
    display: none;
    padding: 3.75rem 1rem 1.25rem;
    overflow-y: auto;
  }

  #inventoryOverlay.visible {
    display: block;
  }

  .inventory-capacity {
    text-align: center;
    font-size: 0.9rem;
    color: var(--muted);
    margin-bottom: 1rem;
  }
  
  .inventory-capacity .capacity-full {
    color: #ff6b6b;
  }

  .inventory-slot {
    display: flex;
    gap: 0.5rem;
    align-items: center;
    background: rgba(255,255,255,0.04);
    border-radius: 0.75rem;
    padding: 0.5rem;
    margin-bottom: 0.5rem;
  }

  .inventory-slot input {
    flex: 1;
    background: transparent;
    border: none;
    color: white;
    font-size: 1rem;
    outline: none;
  }

  .inventory-slot .clear-btn {
    background: rgba(255,0,0,0.25);
    border: none;
    border-radius: 50%;
    width: 1.5rem;
    height: 1.5rem;
    cursor: pointer;
    color: white;
  }

.inventory-item img {
  object-fit: cover;
  border-radius: 0.5rem;
}

.inventory-item[data-slot="artefact"] img {
  width: 6rem;
  height: 6rem;
}

.inventory-item[data-slot="iris"] img {
  width: 5rem;
  height: 5rem;
}

.inventory-item[data-slot="item"] img {
  width: 7.6rem;
  height: 10.6rem;
  /* 2025 Enhancement: Maintain aspect ratio for item images (1218x1698) */
  object-fit: cover;
}

/* Ensure item inv-image container matches the new size */
.inventory-item[data-slot="item"] .inv-image {
  width: 7.6rem;
  height: 10.6rem;
}

/* Inventory cards - match NPC card layout */
.inventory-item {
  background: rgba(255, 255, 255, 0.03);
  border-radius: 1rem;
  padding: 0.5rem;
  margin-bottom: 0.5rem;
  display: flex;
  gap: 0.5rem;
  align-items: stretch;
  position: relative;
}

.inventory-item .inv-image {
  width: 7.6rem;
  height: 10.6rem;
/*  aspect-ratio: 1218 / 1698;
  -webkit-aspect-ratio: 1218 / 1698;
  perspective: 1000px;
  -webkit-perspective: 1000px;*/
  min-width: 3.8rem;
  background: rgba(255, 255, 255, 0.05);
  border: 0.125rem dashed rgba(255, 255, 255, 0.2);
  border-radius: 0.75rem;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.2s ease;
  overflow: hidden;
}

.inventory-item .inv-image:hover {
  border-color: rgba(255, 255, 255, 0.4);
  background: rgba(255, 255, 255, 0.08);
}

.inventory-item .inv-image.has-image {
  border-style: solid;
  border-color: rgba(255, 255, 255, 0.1);
}

.inventory-item .inv-image img {
  width: 100%;
  height: 100%;
  object-fit: cover;
  border-radius: 0.625rem;
}

.inventory-item .inv-image svg {
  width: 2rem;
  height: 2rem;
  stroke: rgba(255, 255, 255, 0.3);
  stroke-width: 2;
  fill: none;
}

.inventory-item .inv-info {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 0.3rem;
  min-width: 0;
}

.inventory-item .inv-name {
  font-size: 1.1rem;
  font-weight: 700;
  color: #fff;
  background: transparent;
  border: none;
  outline: none;
  padding: 0.25rem 0;
  width: 100%;
}

.inventory-item .inv-name::placeholder {
  color: rgba(255, 255, 255, 0.4);
}

.inventory-item .inv-name.locked {
  color: var(--gold);
  pointer-events: none;
}

.inventory-item .inv-type {
  font-size: 1rem;
  color: var(--muted);
  padding-left: 0.25rem;
}

.inventory-item .inv-description {
  font-size: 1rem;
  color: rgba(255, 255, 255, 0.7);
  white-space: pre-line;
  line-height: 1.4;
  margin-top: 0.25rem;
  padding-left: 0.25rem;
  flex: 1;
}

.inventory-item .inv-confirm-btn {
  position: absolute;
  top: 0.5rem;
  right: 0.5rem;
  width: 1.5rem;
  height: 1.5rem;
  background: rgba(76, 175, 80, 0.2);
  border: 0.0625rem solid rgba(76, 175, 80, 0.5);
  border-radius: 0.25rem;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.2s ease;
  opacity: 0;
  pointer-events: none;
}

.inventory-item .inv-confirm-btn.visible {
  opacity: 1;
  pointer-events: auto;
}

.inventory-item .inv-confirm-btn:hover {
  background: rgba(76, 175, 80, 0.4);
  border-color: rgba(76, 175, 80, 0.8);
}

.inventory-item .inv-confirm-btn svg {
  width: 1rem;
  height: 1rem;
  stroke: #4caf50;
  stroke-width: 3;
  fill: none;
}

.inventory-item .inv-delete-btn {
  position: absolute;
  bottom: 0.5rem;
  right: 0.5rem;
  width: 1.5rem;
  height: 1.5rem;
  background: rgba(255, 0, 0, 0.25);
  border: none;
  border-radius: 50%;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  opacity: 0;
  transition: all 0.2s ease;
}

.inventory-item:hover .inv-delete-btn {
  opacity: 1;
}

.inventory-item .inv-delete-btn:hover {
  background: rgba(255, 0, 0, 0.5);
}

.inventory-item .inv-delete-btn svg {
  width: 0.75rem;
  height: 0.75rem;
  stroke: white;
  stroke-width: 2;
  fill: none;
}


  /* Bottom Stats Bar */
  #bottomStats {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    background: rgba(18, 18, 18, 0.95);
    padding: 0.5rem 0.25rem;
    text-align: center;
    font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
    border-top: 0.0625rem solid rgba(255, 255, 255, 0.1);
    z-index: 1;
  }
  #bottomStats span {
    display: inline-block;
    margin: 0.0625rem 0.125rem;
    font-weight: bold;
    color: #fff;
  }
  #bottomStats .stat-label {
    color: #FFF;
    font-weight: 600;
  }

  #bottomStats .stat-value {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 5ch;
    padding: 0.125rem 1rem;
    box-sizing: border-box;
    border-radius: 0.25rem;
    border: 0.125rem solid rgba(230, 227, 200, 0.25);
    font-variant-numeric: tabular-nums;
    font-feature-settings: "tnum";
  }

  /* ===== ACCESSIBILITY & PERFORMANCE ===== */

  /* Respect user's motion preferences */
  @media (prefers-reduced-motion: reduce) {
    .bar-icon,
    .bar-card,
    .attr,
    .heart-icon,
    .btn {
      transition: none !important;
      animation: none !important;
    }
    
    .bar-icon {
      opacity: 1 !important;
      transform: translate(-50%, -50%) scale(1) !important;
    }
    
    .progress-ring .progress-bar {
      animation: none !important;
      stroke-dashoffset: 0 !important;
    }
  }

  /* High contrast mode support */
  @media (prefers-contrast: high) {
    .bar-icon {
      filter: drop-shadow(0 0.125rem 0.25rem rgba(0, 0, 0, 0.8));
    }
    
    .progress-ring circle {
      stroke-width: 0.25rem;
    }
  }

  /* Focus management for accessibility */
  .bar-card:focus-within .bar-icon {
    /* Optionally show icon on keyboard focus */
  }

  /* ===== ATTRIBUTE ICONS ===== */
  .attr-value-wrap {
    display: inline-flex;
    align-items: center;
    gap: 0.375rem;
  }

  .attr-icon {
    width: 2rem;
    height: 2rem;
    padding: 0.0625rem;
    object-fit: contain;
    image-rendering: -webkit-optimize-contrast;
    image-rendering: crisp-edges;
    filter: drop-shadow(0 0.125rem 0.1875rem rgba(0,0,0,0.4));
    flex-shrink: 0;
  }

  /* 2025 Enhanced Focus Indicators for Accessibility */
  .attr:focus-visible {
    outline: 0.125rem solid var(--accent-purple);
    outline-offset: 0.125rem;
    /* Modern focus ring with better visual hierarchy */
    box-shadow: 0 0 0.75rem rgba(106, 27, 154, 0.6);
    /* Enhanced focus state with scale transform */
    transform: translateY(-0.125rem);
  }
  
  /* 2025 Enhancement: Special gold focus for luck attribute */
  .attr.luck:focus-visible {
    outline: 0.125rem solid var(--gold);
    outline-offset: 0.125rem;
    box-shadow: 0 0 0.75rem rgba(212, 175, 55, 0.6);
    transform: translateY(-0.125rem);
  }

  .attr:focus-visible .progress-ring {
    opacity: 1;
  }
  
  /* 2025 Modern Hover Enhancement */
  .attr:is(:hover, :focus-visible) {
    transform: translateY(-0.125rem);
    box-shadow: 0 0.75rem 1.5rem rgba(106, 27, 154, 0.4);
  }
  
  /* 2025 Enhancement: Special gold hover for luck */
  .attr.luck:is(:hover, :focus-visible) {
    transform: translateY(-0.125rem);
    box-shadow: 0 0.75rem 1.5rem rgba(212, 175, 55, 0.5);
  }
  
  /* 2025 Enhanced Press-and-Hold Animation */
  .attr.holding {
    animation: progressiveShadow var(--hold-duration) var(--hold-easing) forwards;
    /* Enhanced holding state with subtle scale */
    transform: scale(1.02);
  }
  
  /* Modern keyframe animation with improved easing */
  @keyframes progressiveShadow {
    0% { 
      box-shadow: 0 0 1rem rgba(255, 255, 255, 0.4);
      transform: scale(1.02);
    }
    50% { 
      box-shadow: 0 0 1.5rem rgba(255, 255, 255, 0.7);
      transform: scale(1.04);
    }
    100% { 
      box-shadow: 0 0 2rem rgba(255, 255, 255, 0.9);
      transform: scale(1.06);
    }
  }

</style>
</head>
<body>
  <button id="resetBtn">RESET</button>
  
  <!-- Backpack Button -->
  <button id="inventoryBtn" aria-label="Toggle Inventory">
<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" 
   viewBox="0 0 512 512" xml:space="preserve">
<g>
  <path style="fill:#C8A27D;" d="M409.934,8.017h-34.205c-4.722,0-8.551,3.829-8.551,8.551v145.37h51.307V16.568
    C418.485,11.845,414.656,8.017,409.934,8.017z"/>
  <path style="fill:#C8A27D;" d="M136.297,8.017h-34.205c-4.722,0-8.551,3.829-8.551,8.551v145.37h51.307V16.568
    C144.848,11.845,141.019,8.017,136.297,8.017z"/>
</g>
<g>
  <path style="fill:#DCB991;" d="M119.169,161.937H93.541V16.568c0-4.722,3.829-8.551,8.551-8.551h17.077V161.937z"/>
  <path style="fill:#DCB991;" d="M418.485,161.937h-25.679V8.017h17.128c4.722,0,8.551,3.829,8.551,8.551V161.937z"/>
  <path style="fill:#DCB991;" d="M67.862,298.756c-9.445,0-17.102,7.656-17.102,17.102v136.818c0,9.445,7.658,17.102,17.102,17.102
    h17.102V298.756H67.862z"/>
</g>
<rect x="50.762" y="350.063" style="fill:#C8A27D;" width="34.205" height="25.653"/>
<path style="fill:#DCB991;" d="M444.112,298.756H427.01v171.023h17.102c9.445,0,17.102-7.658,17.102-17.102V315.858
  C461.215,306.412,453.557,298.756,444.112,298.756z"/>
<rect x="427.012" y="350.063" style="fill:#C8A27D;" width="34.205" height="25.653"/>
<path style="fill:#EBC9A0;" d="M392.831,503.983H119.194c-18.891,0-34.205-15.314-34.205-34.205V161.937
  c0-56.672,45.942-102.614,102.614-102.614h136.818c56.672,0,102.614,45.942,102.614,102.614v307.841
  C427.036,488.669,411.722,503.983,392.831,503.983z"/>
<path style="fill:#DCB991;" d="M401.382,94.222c-18.804-21.354-46.27-34.898-76.961-34.898H187.603
  c-30.689,0-58.154,13.544-76.959,34.897v67.717c0,61.297,49.868,111.165,111.165,111.165h68.409
  c61.297,0,111.165-49.868,111.165-111.165V94.222z"/>
<path style="fill:#F5DCB4;" d="M367.178,469.779h-222.33c-9.446,0-17.102-7.656-17.102-17.102V315.858
  c0-9.446,7.656-17.102,17.102-17.102h222.33c9.446,0,17.102,7.656,17.102,17.102v136.818
  C384.28,462.122,376.624,469.779,367.178,469.779z"/>
<path style="fill:#C8A27D;" d="M367.178,298.756h-222.33c-9.446,0-17.102,7.656-17.102,17.102v34.205H384.28v-34.205
  C384.28,306.412,376.624,298.756,367.178,298.756z"/>
<path style="fill:#F5DCB4;" d="M358.627,59.324H153.399c-9.445,0-17.102,7.656-17.102,17.102v85.511
  c0,47.227,38.285,85.511,85.511,85.511h68.409c47.227,0,85.512-38.285,85.512-85.511V76.426
  C375.729,66.98,368.071,59.324,358.627,59.324z"/>
<g>
  <path style="fill:#C8A27D;" d="M256.013,264.551L256.013,264.551c-9.446,0-17.102-7.656-17.102-17.102v-34.205h34.205v34.205
    C273.115,256.895,265.459,264.551,256.013,264.551z"/>
  <circle style="fill:#C8A27D;" cx="307.318" cy="392.818" r="17.102"/>
</g>
<path d="M367.165,290.739h-222.33c-13.851,0-25.119,11.268-25.119,25.119v136.818c0,13.851,11.268,25.119,25.119,25.119h222.33
  c13.851,0,25.119-11.268,25.119-25.119V315.858C392.284,302.007,381.016,290.739,367.165,290.739z M376.251,452.676
  c0,5.01-4.076,9.086-9.086,9.086h-222.33c-5.01,0-9.086-4.076-9.086-9.086V315.858c0-5.01,4.076-9.086,9.086-9.086h222.33
  c5.01,0,9.086,4.076,9.086,9.086V452.676z"/>
<path d="M350.063,342.046H161.937c-4.427,0-8.017,3.589-8.017,8.017c0,4.427,3.589,8.017,8.017,8.017H299.29v10.939
  c-9.93,3.354-17.102,12.752-17.102,23.8c0,13.851,11.268,25.119,25.119,25.119c13.851,0,25.119-11.268,25.119-25.119
  c0-11.048-7.172-20.446-17.102-23.8v-10.939h34.739c4.427,0,8.017-3.589,8.017-8.017
  C358.079,345.635,354.49,342.046,350.063,342.046z M307.307,401.904c-5.01,0-9.086-4.076-9.086-9.086s4.076-9.086,9.086-9.086
  s9.086,4.076,9.086,9.086S312.317,401.904,307.307,401.904z"/>
<path d="M444.125,290.739h-9.086V161.937c0-14.813-3.003-29.249-8.562-42.548c0.002-0.069,0.011-0.138,0.011-0.207V16.568
  C426.489,7.432,419.057,0,409.921,0h-34.205c-9.136,0-16.568,7.432-16.568,16.568v34.753c-0.178-0.003-0.355-0.014-0.534-0.014
  h-34.739V33.67c0-18.566-15.105-33.67-33.67-33.67h-68.409c-18.566,0-33.67,15.105-33.67,33.67v17.637h-34.739
  c-0.18,0-0.356,0.01-0.534,0.014V16.568C152.852,7.432,145.42,0,136.284,0h-34.205c-9.136,0-16.568,7.432-16.568,16.568v102.614
  c0,0.069,0.009,0.137,0.011,0.206c-5.559,13.299-8.562,27.736-8.562,42.549v128.802h-9.086c-13.851,0-25.119,11.268-25.119,25.119
  v136.818c0,13.851,11.268,25.119,25.119,25.119h9.858C81.49,497.255,98.642,512,119.182,512h273.637
  c20.54,0,37.691-14.745,41.448-34.205h9.858c13.851,0,25.119-11.268,25.119-25.119V315.858
  C469.244,302.007,457.976,290.739,444.125,290.739z M444.125,306.772c5.01,0,9.086,4.076,9.086,9.086v26.188H435.04v-35.273H444.125
  z M375.182,16.568c0-0.295,0.239-0.534,0.534-0.534h34.205c0.295,0,0.534,0.239,0.534,0.534v75.916
  c-7.859-9.76-17.405-18.24-28.351-24.946c-1.469-3.869-3.867-7.282-6.922-9.97V16.568z M204.159,33.67
  c0-9.725,7.912-17.637,17.637-17.637h68.409c9.725,0,17.637,7.912,17.637,17.637v17.637H204.159V33.67z M358.614,67.34
  c5.01,0,9.086,4.076,9.086,9.086v85.511c0,42.731-34.764,77.495-77.495,77.495h-9.086v-26.188c0-4.427-3.589-8.017-8.017-8.017
  h-34.205c-4.427,0-8.017,3.589-8.017,8.017v26.188h-9.086c-42.731,0-77.495-34.764-77.495-77.495V76.426
  c0-5.01,4.076-9.086,9.086-9.086H358.614z M265.086,247.438c0,0.003,0,0.006,0,0.011c0,0.002,0,0.003,0,0.005
  c-0.003,5.008-4.077,9.08-9.086,9.08c-5.01,0-9.086-4.076-9.086-9.086v-26.188h18.171V247.438z M101.545,16.568
  c0-0.295,0.239-0.534,0.534-0.534h34.205c0.295,0,0.534,0.239,0.534,0.534v41.001c-3.055,2.687-5.453,6.1-6.922,9.97
  c-10.947,6.706-20.493,15.186-28.351,24.946V16.568z M67.875,306.772h9.086v35.273H58.789v-26.188
  C58.789,310.848,62.865,306.772,67.875,306.772z M58.789,452.676v-94.597H76.96v103.683h-9.086
  C62.865,461.762,58.789,457.686,58.789,452.676z M392.818,495.967H119.182c-14.44,0-26.188-11.748-26.188-26.188V161.937
  c0-28.758,13.233-55.853,35.273-73.665v73.665c0,51.572,41.956,93.528,93.528,93.528H232.2c3.354,9.93,12.752,17.102,23.8,17.102
  c11.048,0,20.446-7.172,23.8-17.102h10.405c51.572,0,93.528-41.956,93.528-93.528V88.272c22.041,17.812,35.273,44.907,35.273,73.665
  v307.841C419.006,484.218,407.258,495.967,392.818,495.967z M444.125,461.762h-9.086V358.079h18.171v94.597
  C453.211,457.686,449.135,461.762,444.125,461.762z"/>
</svg>
  </button>

  <!-- Heart Button -->
  <button id="heartBtn" aria-label="Toggle Relationships">
    <svg viewBox="0 0 24 24">
      <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"/>
    </svg>
  </button>

  <!-- Relationship Overlay -->
  <div id="relationshipOverlay">
    <div class="relationship-content">
      <div class="relationship-title" id="relationshipTitle">Relationships</div>
      <div id="npcList"></div>
      <button class="add-npc-btn" id="addNpcBtn">
        <svg viewBox="0 0 24 24">
          <line x1="12" y1="5" x2="12" y2="19"/>
          <line x1="5" y1="12" x2="19" y2="12"/>
        </svg>
        Add Character
      </button>
    </div>
  </div>

  <!-- Backpack Overlay -->
<div id="inventoryOverlay">
  <div class="relationship-content">
    <div class="relationship-title">Inventory</div>
    <div id="inventoryCapacity" class="inventory-capacity"></div>
    <div id="inventoryList"></div>

    <button class="add-npc-btn" id="addInventoryItem">
      <svg viewBox="0 0 24 24">
        <line x1="12" y1="5" x2="12" y2="19"/>
        <line x1="5" y1="12" x2="19" y2="12"/>
      </svg>
      Add Item
    </button>
  </div>
</div>

  <div class="wrap">
    <input id="playerName" placeholder="PLAYER" aria-label="Player name" />

    <div class="bars" id="bars"></div>

    <div class="attributes" id="attributes"></div>
  </div>
    <!-- Bottom spacer to provide breathing room for the last entry -->
    <div style="height: 3rem;"></div>
  <!-- Bottom Stats Bar -->
  <div id="bottomStats">
    <span class="stat-label">Level:</span><span class="stat-value" id="levelValue" style="background-color: rgba(106, 27, 154, 0.3)">1</span>
    <span class="stat-label">Tinge:</span><span class="stat-value" id="tingeValue" style="background: linear-gradient(180deg,#F5B727,#F57927)">0</span>
    <span class="stat-label">Arcane:</span><span class="stat-value" id="arcaneValue" style="background: linear-gradient(45deg,#27F5CC,#133bbb)">0</span>
  </div>

<script>
/* ========= MODERN TOUCH INTERACTION MANAGER ========= */

/**
 * Simplified Press-and-Hold Manager
 * Implements clean 2.5-second hold with progress ring and flash
 */
class SimpleTouchManager {
  constructor(options = {}) {
    this.config = {
      holdDuration: options.holdDuration || 2500, // 2.5 seconds
      moveThreshold: options.moveThreshold || 10,
      showProgress: options.showProgress !== false,
      hapticFeedback: options.hapticFeedback !== false,
      ...options
    };
    
    this.activeHolds = new Map();
    this.isTouchDevice = this.detectTouchDevice();
    
    this.handlePointerDown = this.handlePointerDown.bind(this);
    this.handlePointerMove = this.handlePointerMove.bind(this);
    this.handlePointerUp = this.handlePointerUp.bind(this);
    this.handlePointerCancel = this.handlePointerCancel.bind(this);
  }
  
  detectTouchDevice() {
    return (
      'ontouchstart' in window ||
      navigator.maxTouchPoints > 0 ||
      navigator.msMaxTouchPoints > 0
    );
  }
  
  attach(element, onActivate, options = {}) {
    const elementOptions = { ...this.config, ...options };
    
    element.setAttribute('role', 'button');
    element.setAttribute('aria-label', options.ariaLabel || 'Press and hold to activate');
    element.setAttribute('tabindex', '0');
    
    // Set custom colors if provided
    if (options.progressColor) {
      element.style.setProperty('--progress-color', options.progressColor);
      element.style.setProperty('--progress-bg', options.progressColor + '33'); // Add transparency
    }
    if (options.flashColor) {
      element.style.setProperty('--flash-color', options.flashColor);
    }
    
    element.addEventListener('contextmenu', (e) => e.preventDefault());
    
    element.addEventListener('pointerdown', (e) => this.handlePointerDown(e, element, onActivate, elementOptions));
    element.addEventListener('pointermove', (e) => this.handlePointerMove(e, element));
    element.addEventListener('pointerup', (e) => this.handlePointerUp(e, element));
    element.addEventListener('pointercancel', (e) => this.handlePointerCancel(e, element));
    element.addEventListener('pointerleave', (e) => this.handlePointerCancel(e, element));
    
    element.addEventListener('keydown', (e) => {
      if (e.code === 'Space' || e.code === 'Enter') {
        e.preventDefault();
        this.simulateHold(element, onActivate, elementOptions);
      }
    });
    
    // Removed click-based activation - stats only increase when hold completes
    // This prevents premature stat increases on desktop clicks
    
    // Desktop users can use keyboard: Space or Enter keys to activate
    
    if (this.isTouchDevice) {
      element.classList.add('mobile-only');
    }
  }
  
  handlePointerDown(e, element, onActivate, options) {
    if (!this.isTouchDevice && e.pointerType !== 'mouse') return;
    
    e.preventDefault();
    
    const startX = e.clientX;
    const startY = e.clientY;
    const startTime = Date.now();
    
    if (options.showProgress) {
      this.createProgressRing(element);
    }
    
    element.classList.add('holding');
    
    const holdState = {
      timer: null,
      startX,
      startY,
      startTime,
      element,
      onActivate,
      options
    };
    
    this.activeHolds.set(element, holdState);
    
    holdState.timer = setTimeout(() => {
      this.completeHold(element, holdState);
    }, options.holdDuration);
    
    if (options.hapticFeedback && 'vibrate' in navigator) {
      navigator.vibrate(50);
    }
  }
  
  handlePointerMove(e, element) {
    const holdState = this.activeHolds.get(element);
    if (!holdState) return;
    
    const deltaX = Math.abs(e.clientX - holdState.startX);
    const deltaY = Math.abs(e.clientY - holdState.startY);
    
    if (deltaX > this.config.moveThreshold || deltaY > this.config.moveThreshold) {
      this.cancelHold(element, holdState);
    }
  }
  
  handlePointerUp(e, element) {
    const holdState = this.activeHolds.get(element);
    if (!holdState) return;
    
    const duration = Date.now() - holdState.startTime;
    
    if (duration >= holdState.options.holdDuration) {
      element.setAttribute('data-hold-activated', 'true');
    }
    
    this.cancelHold(element, holdState);
  }
  
  handlePointerCancel(e, element) {
    const holdState = this.activeHolds.get(element);
    if (!holdState) return;
    
    this.cancelHold(element, holdState);
  }
  
  completeHold(element, holdState) {
    if (holdState.options.hapticFeedback && 'vibrate' in navigator) {
      navigator.vibrate([100, 50, 100]);
    }
    
    element.classList.remove('holding');
    element.classList.add('flash');
    
    holdState.onActivate();
    
    setTimeout(() => {
      element.classList.remove('flash');
    }, 400); /* Match the goldFlash animation duration */
    
    this.activeHolds.delete(element);
  }
  
  cancelHold(element, holdState) {
    clearTimeout(holdState.timer);
    element.classList.remove('holding');
    this.removeProgressRing(element);
    this.activeHolds.delete(element);
  }
  
  simulateHold(element, onActivate, options) {
    element.classList.add('holding');
    
    if (options.showProgress) {
      this.createProgressRing(element);
    }
    
    setTimeout(() => {
      element.classList.remove('holding');
      element.classList.add('flash');
      onActivate();
      
      setTimeout(() => {
        element.classList.remove('flash');
      }, 400); /* Match the goldFlash animation duration */
    }, options.holdDuration);
  }
  
  createProgressRing(element) {
    if (element.querySelector('.progress-ring')) return;
    
    const progressRing = document.createElement('div');
    progressRing.className = 'progress-ring';
    
    // Fixed dimensions for consistent circular progress
    const radius = 42;
    const circumference = 2 * Math.PI * radius;
    
    // Get colors from CSS variables or use defaults
    const progressColor = getComputedStyle(element).getPropertyValue('--progress-color').trim() || '#ffffff';
    const progressBg = getComputedStyle(element).getPropertyValue('--progress-bg').trim() || 'rgba(255, 255, 255, 0.2)';
    
    progressRing.innerHTML = `
      <svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
        <circle class="progress-bg" cx="50" cy="50" r="${radius}" stroke="${progressBg}"/>
        <circle class="progress-bar" cx="50" cy="50" r="${radius}" 
                stroke="${progressColor}"
                stroke-dasharray="${circumference} ${circumference}" 
                stroke-dashoffset="${circumference}"/>
      </svg>
    `;
    
    element.appendChild(progressRing);
    
    // Set CSS custom property for animation
    const progressBar = progressRing.querySelector('.progress-bar');
    progressBar.style.setProperty('--circumference', circumference);
  }
  
  removeProgressRing(element) {
    const progressRing = element.querySelector('.progress-ring');
    if (progressRing) {
      progressRing.remove();
    }
  }
}

/* ========= touchscreen misclick prevention ========= */
const touchManager = new SimpleTouchManager({
  holdDuration: 2600,
  showProgress: true,
  hapticFeedback: true,
  moveThreshold: 10
});

/* ========= SVG buttons ========= */
const minusSVG = `
<svg viewBox="0 0 24 24" aria-hidden="true">
  <path opacity="0.5"
        d="M2 12C2 7.28595 2 4.92893 3.46447 3.46447
           C4.92893 2 7.28595 2 12 2
           C16.714 2 19.0711 2 20.5355 3.46447
           C22 4.92893 22 7.28595 22 12
           C22 16.714 22 19.0711 20.5355 20.5355
           C19.0711 22 16.714 22 12 22
           C7.28595 22 4.92893 22 3.46447 20.5355
           C2 19.0711 2 16.714 2 12Z"
        fill="none"
        stroke="currentColor"
        stroke-width="1.5"/>
  <path d="M15 12H9"
        stroke="currentColor"
        stroke-width="1.5"
        stroke-linecap="round"/>
</svg>
`;

const plusSVG = `
<svg viewBox="0 0 24 24" aria-hidden="true">
  <path opacity="0.5"
        d="M2 12C2 7.28595 2 4.92893 3.46447 3.46447
           C4.92893 2 7.28595 2 12 2
           C16.714 2 19.0711 2 20.5355 3.46447
           C22 4.92893 22 7.28595 22 12
           C22 16.714 22 19.0711 20.5355 20.5355
           C19.0711 22 16.714 22 12 22
           C7.28595 22 4.92893 22 3.46447 20.5355
           C2 19.0711 2 16.714 2 12Z"
        fill="none"
        stroke="currentColor"
        stroke-width="1.5"/>
  <path d="M12 9V15M9 12H15"
        stroke="currentColor"
        stroke-width="1.5"
        stroke-linecap="round"/>
</svg>
`;

/* ========= Persistence helpers ========= */
function saveState(key,value){ try{ localStorage.setItem(key, JSON.stringify(value)); }catch(e){} }
function loadState(key, fallback){ try{ const v = localStorage.getItem(key); return v ? JSON.parse(v) : fallback; }catch(e){ return fallback; } }

/* ========= Bottom Stats Calculations ========= */
function calculateLevel() {
  const endurance = Number(loadState('Endurance', 0)) || 0;
  const skill = Number(loadState('Skill', 0)) || 0;
  const strength = Number(loadState('Strength', 0)) || 0;
  const mastery = Number(loadState('Mastery', 0)) || 0;
  const potency = Number(loadState('Potency', 0)) || 0;
  
  return 1 + endurance + skill + strength + mastery + potency;
}

function calculateTinge() {
  const potency = Number(loadState('Potency', 0)) || 0;
  const currentMana = Number(loadState('mana', 0)) || 0;
  
  console.log('Tinge calc - Potency:', potency, 'Current Mana:', currentMana, 'Total:', potency + currentMana);
  return potency + currentMana;
}

function calculateArcane() {
  const mastery = Number(loadState('Mastery', 0)) || 0;
  const currentEnergy = Number(loadState('energy', 0)) || 0;
  
  console.log('Arcane calc - Mastery:', mastery, 'Current Energy:', currentEnergy, 'Total:', mastery + currentEnergy);
  return mastery + currentEnergy;
}

function updateBottomStats() {
  const level = calculateLevel();
  const tinge = calculateTinge();
  const arcane = calculateArcane();
  
  console.log('Bottom Stats Update - Level:', level, 'Tinge:', tinge, 'Arcane:', arcane);
  document.getElementById('levelValue').textContent = level;
  document.getElementById('tingeValue').textContent = tinge;
  document.getElementById('arcaneValue').textContent = arcane;
}

/* ========= Stat Bonus Tables ========= */
const enduranceBonuses = [
  null,
  { life: 2, stamina: 1, mana: 0, energy: 0 },
  { life: 2, stamina: 1, mana: 0, energy: 0 },
  { life: 2, stamina: 1, mana: 0, energy: 0 },
  { life: 2, stamina: 1, mana: 0, energy: 0 },
  { life: 2, stamina: 1, mana: 0, energy: 0 },
  { life: 2, stamina: 1, mana: 0, energy: 0 },
  { life: 1, stamina: 0, mana: 0, energy: 0 },
  { life: 1, stamina: 0, mana: 0, energy: 0 },
  { life: 1, stamina: 0, mana: 0, energy: 0 },
];

const skillBonuses = [
  null,
  { life: 1, stamina: 0, mana: 0, energy: 0 },
  { life: 1, stamina: 1, mana: 0, energy: 0 },
  { life: 1, stamina: 0, mana: 0, energy: 0 },
  { life: 1, stamina: 0, mana: 0, energy: 0 },
  { life: 1, stamina: 0, mana: 0, energy: 0 },
  { life: 1, stamina: 0, mana: 0, energy: 0 },
  { life: 0, stamina: 0, mana: 0, energy: 0 },
  { life: 0, stamina: 0, mana: 0, energy: 0 },
  { life: 0, stamina: 0, mana: 0, energy: 0 },
];

const strengthBonuses = [
  null,
  { life: 1, stamina: 0, mana: 0, energy: 0 },
  { life: 1, stamina: 0, mana: 0, energy: 0 },
  { life: 1, stamina: 0, mana: 0, energy: 0 },
  { life: 1, stamina: 0, mana: 0, energy: 0 },
  { life: 1, stamina: 1, mana: 0, energy: 0 },
  { life: 1, stamina: 0, mana: 0, energy: 0 },
  { life: 0, stamina: 0, mana: 0, energy: 0 },
  { life: 0, stamina: 0, mana: 0, energy: 0 },
  { life: 0, stamina: 0, mana: 0, energy: 0 },
];

const potencyBonuses = [
  null,
  { life: 0, stamina: 0, mana: 3, energy: 0 },
  { life: 0, stamina: 0, mana: 2, energy: 1 },
  { life: 0, stamina: 0, mana: 3, energy: 0 },
  { life: 0, stamina: 0, mana: 2, energy: 1 },
  { life: 0, stamina: 0, mana: 3, energy: 0 },
  { life: 0, stamina: 0, mana: 3, energy: 0 },
  { life: 0, stamina: 0, mana: 2, energy: 0 },
  { life: 0, stamina: 0, mana: 2, energy: 0 },
  { life: 0, stamina: 0, mana: 3, energy: 0 },
];

const masteryBonuses = [
  null,
  { life: 0, stamina: 0, mana: 1, energy: 2 },
  { life: 0, stamina: 0, mana: 0, energy: 3 },
  { life: 0, stamina: 0, mana: 1, energy: 3 },
  { life: 0, stamina: 0, mana: 0, energy: 3 },
  { life: 0, stamina: 0, mana: 1, energy: 2 },
  { life: 0, stamina: 0, mana: 0, energy: 3 },
  { life: 0, stamina: 0, mana: 0, energy: 2 },
  { life: 0, stamina: 0, mana: 1, energy: 2 },
  { life: 0, stamina: 0, mana: 0, energy: 2 },
];

/* ========= Calculate Maximum Limits ========= */
function calculateLimits() {
  const limits = {
    life: 3,
    stamina: 1,
    mana: 3,
    energy: 2
  };

  const endurance = Number(loadState('Endurance', 0)) || 0;
  const skill = Number(loadState('Skill', 0)) || 0;
  const strength = Number(loadState('Strength', 0)) || 0;
  const potency = Number(loadState('Potency', 0)) || 0;
  const mastery = Number(loadState('Mastery', 0)) || 0;

  function sumBonuses(bonusTable, rank) {
    let total = { life: 0, stamina: 0, mana: 0, energy: 0 };
    for (let i = 1; i <= rank && i < bonusTable.length; i++) {
      if (bonusTable[i]) {
        total.life += bonusTable[i].life;
        total.stamina += bonusTable[i].stamina;
        total.mana += bonusTable[i].mana;
        total.energy += bonusTable[i].energy;
      }
    }
    return total;
  }

  const endBonus = sumBonuses(enduranceBonuses, endurance);
  const skillBonus = sumBonuses(skillBonuses, skill);
  const strBonus = sumBonuses(strengthBonuses, strength);
  const potBonus = sumBonuses(potencyBonuses, potency);
  const mastBonus = sumBonuses(masteryBonuses, mastery);

  limits.life += endBonus.life + skillBonus.life + strBonus.life + potBonus.life + mastBonus.life;
  limits.stamina += endBonus.stamina + skillBonus.stamina + strBonus.stamina + potBonus.stamina + mastBonus.stamina;
  limits.mana += endBonus.mana + skillBonus.mana + strBonus.mana + potBonus.mana + mastBonus.mana;
  limits.energy += endBonus.energy + skillBonus.energy + strBonus.energy + potBonus.energy + mastBonus.energy;

  return limits;
}

/* ========= Bar Update Registry ========= */
const barUpdateFunctions = {};

/* ========= Bars config with min/max ranges and defaults ========= */
const barsConfig = [
  { key:'life', label:'Life', dotClass:'dot-life', min: -10, max: 30, default: 3, dynamic: true },
  { key:'mana', label:'Mana', dotClass:'dot-mana', min: -1, max: 30, default: 0, dynamic: true },
  { key:'stamina', label:'Stamina', dotClass:'dot-stamina', min: -3, max: 9, default: 1, dynamic: true },
  { key:'energy', label:'Energy', dotClass:'dot-energy', min: -1, max: 30, default: 0, dynamic: true },
  { key:'empower', label:'Empower', dotClass:'dot-empower', min: 0, max: 12, default: 0, dynamic: false },
  { key:'coalesce', label:'Coalesce', dotClass:'dot-coalesce', min: 0, max: 12, default: 3, dynamic: false }
];

const barsContainer = document.getElementById('bars');

/* ========= ICON MANAGEMENT SYSTEM ========= */

function createBarIcon(barKey, barLabel) {
  const iconContainer = document.createElement('div');
  iconContainer.className = `bar-icon bar-icon--${barKey}`;
  iconContainer.setAttribute('role', 'img');
  iconContainer.setAttribute('aria-label', `${barLabel} icon`);
  
  const img = document.createElement('img');
  img.alt = `${barLabel} icon`;
  img.decoding = 'async';
  img.loading = 'lazy';
  
  const iconPaths = {
    life: '../icons/life1.png',
    mana: '../icons/mana1.png',
    stamina: '../icons/stamina1.png',
    energy: '../icons/energy1.png',
    empower: '../icons/empower1.png',
    coalesce: '../icons/crys.svg'
  };
  
  img.src = iconPaths[barKey] || iconPaths.life;
  iconContainer.appendChild(img);
  
  return iconContainer;
}

class IconAnimationManager {
  constructor() {
    this.activeAnimations = new Map();
    this.animationConfig = {
      fadeInDuration: 300,
      lingerDuration: 3000,
      fadeOutDuration: 2000
    };
  }

  showIcon(iconElement) {
    this.clearAnimation(iconElement);
    
    iconElement.classList.add('visible');
    iconElement.classList.remove('fading');
    
    const timer = setTimeout(() => {
      this.fadeOutIcon(iconElement);
    }, this.animationConfig.lingerDuration);
    
    this.activeAnimations.set(iconElement, timer);
  }

  fadeOutIcon(iconElement) {
    this.clearAnimation(iconElement);
    
    iconElement.classList.add('fading');
    
    setTimeout(() => {
      iconElement.classList.remove('visible', 'fading');
      this.activeAnimations.delete(iconElement);
    }, this.animationConfig.fadeOutDuration);
  }

  clearAnimation(iconElement) {
    const timer = this.activeAnimations.get(iconElement);
    if (timer) {
      clearTimeout(timer);
      this.activeAnimations.delete(iconElement);
    }
  }

  handleBarHover(barCard, isHovering) {
    const icon = barCard.querySelector('.bar-icon');
    if (!icon) return;

    if (isHovering) {
      this.showIcon(icon);
    } else {
      this.clearAnimation(icon);
      icon.classList.remove('visible', 'fading');
    }
  }

  cleanup() {
    this.activeAnimations.forEach((timer) => clearTimeout(timer));
    this.activeAnimations.clear();
  }
}

const iconManager = new IconAnimationManager();

barsConfig.forEach(cfg => {
  let value = Number(loadState(cfg.key, cfg.default));
  value = Math.max(cfg.min, Math.min(cfg.max, value));
  console.log('Bar loaded - Key:', cfg.key, 'Value:', value, 'Default:', cfg.default);
  
  const card = document.createElement('div');
  card.className = 'bar-card';
  card.dataset.key = cfg.key;
  card.setAttribute('tabindex', '0');

  const left = document.createElement('div'); left.className='bar-left';
  const dot = document.createElement('div'); dot.className = 'bar-dot ' + cfg.dotClass;
  const label = document.createElement('div'); label.className='bar-label'; label.textContent = cfg.label;

  left.appendChild(dot);
  left.appendChild(label);

  const icon = createBarIcon(cfg.key, cfg.label);
  dot.appendChild(icon);

  const controls = document.createElement('div'); controls.className='bar-controls';

  const valSpan = document.createElement('div'); valSpan.className='bar-value';
  const minus = document.createElement('button');
  minus.className = 'btn btn-icon';
  minus.innerHTML = minusSVG;
  minus.setAttribute('aria-label', 'Decrease');

  const plus = document.createElement('button');
  plus.className = 'btn btn-icon';
  plus.innerHTML = plusSVG;
  plus.setAttribute('aria-label', 'Increase');

  function getCurrentMax() {
    if (cfg.dynamic) {
      const limits = calculateLimits();
      return limits[cfg.key];
    }
    return cfg.max;
  }

  function updateDisplay() {
    if (cfg.dynamic) {
      const currentMax = getCurrentMax();
      valSpan.textContent = `${value} / ${currentMax}`;
    } else {
      valSpan.textContent = String(value);
    }
  }

  function updateButtonStates() {
    const currentMax = getCurrentMax();
    minus.disabled = (value <= cfg.min);
    plus.disabled = (value >= currentMax);
  }

  function updateBar() {
    const currentMax = getCurrentMax();
    if (value > currentMax) {
      value = currentMax;
      saveState(cfg.key, value);
    }
    updateDisplay();
    updateButtonStates();
  }

  if (cfg.dynamic) {
    barUpdateFunctions[cfg.key] = () => {
      updateBar();
      if (cfg.key === 'mana' || cfg.key === 'energy') {
        updateBottomStats();
      }
    };
  }

  minus.addEventListener('click', ()=> {
    const newValue = value - 1;
    if (newValue >= cfg.min) {
      value = newValue;
      updateDisplay();
      saveState(cfg.key, value);
      console.log('Bar decreased - Key:', cfg.key, 'New Value:', value);
      updateButtonStates();
      
      if (cfg.key === 'mana' || cfg.key === 'energy') {
        updateBottomStats();
      }
      
      flashElement(card);
    }
  });
  
  plus.addEventListener('click', ()=> {
    const currentMax = getCurrentMax();
    const newValue = value + 1;
    if (newValue <= currentMax) {
      value = newValue;
      updateDisplay();
      saveState(cfg.key, value);
      console.log('Bar increased - Key:', cfg.key, 'New Value:', value);
      updateButtonStates();
      
      if (cfg.key === 'mana' || cfg.key === 'energy') {
        updateBottomStats();
      }
      
      flashElement(card);
    }
  });

  updateDisplay();
  updateButtonStates();

  controls.appendChild(minus);
  controls.appendChild(valSpan);
  controls.appendChild(plus);

  card.appendChild(left);
  card.appendChild(controls);

  card.addEventListener('mouseenter', () => iconManager.handleBarHover(card, true));
  card.addEventListener('mouseleave', () => iconManager.handleBarHover(card, false));
  
  card.addEventListener('focus', () => iconManager.handleBarHover(card, true));
  card.addEventListener('blur', () => iconManager.handleBarHover(card, false));

  barsContainer.appendChild(card);
});

function updateAllBars() {
  Object.values(barUpdateFunctions).forEach(updateFn => updateFn());
}

function flashElement(el){
  el.style.transition = 'box-shadow .18s ease, transform .12s ease';
  el.style.transform = 'translateY(-0.125rem)';
  el.style.boxShadow = '0 0.875rem 2.25rem rgba(0,0,0,0.55)';
  setTimeout(()=>{ el.style.transform=''; el.style.boxShadow=''; }, 160);
}

/* ===== ATTRIBUTE ICON MAP ===== */
const STAT_ICONS = {
  Endurance: '../icons/heart-shield.png',
  Skill: '../icons/skl.png',
  Strength: '../icons/str.png',
  Potency: '../icons/potency8.png',
  Mastery: '../icons/mastery4.png'
};

/* ========= Attributes (including Luck) ========= */
const attrConfig = ["Endurance","Potency","Mastery","Strength","Skill","Luck"];
const attrsContainer = document.getElementById('attributes');

const limitAffectingAttrs = ["Endurance", "Skill", "Strength", "Potency", "Mastery"];

attrConfig.forEach(name => {
  let stored = loadState(name, name==='Luck' ? null : 0);
  if(name!=='Luck') stored = Number(stored) || 0;

  const card = document.createElement('div');
  card.className = 'attr';
  card.dataset.name = name;
  
  /* 2025 Accessibility Enhancement: ARIA Labels */
  card.setAttribute('role', 'button');
  card.setAttribute('aria-label', `${name === 'Luck' ? 'Press and hold to activate luck' : 'Press and hold to level up'}`);
  card.setAttribute('tabindex', '0');

  const label = document.createElement('div');
  label.className = 'attr-label';
  label.textContent = name;

  const valWrap = document.createElement('div');
  valWrap.className = 'attr-value-wrap';

  const icon = document.createElement('img');
  icon.className = 'attr-icon';

  if (STAT_ICONS[name]) {
    icon.src = STAT_ICONS[name];
    icon.alt = `${name} icon`;
  } else {
    icon.style.display = 'none';
  }

  const val = document.createElement('span');
  val.className = 'attr-val';
  val.textContent = (name === 'Luck' ? '--' : stored);

  valWrap.appendChild(icon);
  valWrap.appendChild(val);

  card.appendChild(label);
  card.appendChild(valWrap);
  attrsContainer.appendChild(card);

    if(name === 'Luck'){
card.classList.add('luck');

let luckValue = loadState('Luck', null);
let showing = Boolean(loadState('luckShowing', false));
let lastLuck = loadState('luckLast', null);
let cooldownUntil = loadState('luckCooldownUntil', null);
let timerId = null;
let expired = false; // ✅ FIX #1

function formatLuck(n){ return (n>=0 ? '+'+n : String(n)); }

function getRemainingSec(){
  if(!cooldownUntil) return 0;
  const rem = Math.ceil((cooldownUntil - Date.now())/1000);
  return rem > 0 ? rem : 0;
}

function updateLuckDisplay(){
  const rem = getRemainingSec();

  if (showing && rem > 0) {
    label.innerHTML = 'Luck <span class="luck-timer"></span>';
    label.querySelector('.luck-timer').textContent = `(${rem}s)`;
    val.textContent = formatLuck(luckValue);
    card.classList.add('cooling');
    expired = false;
  }
  else if (showing && expired) {
    label.innerHTML = 'Luck <span class="luck-timer"></span>';

    val.textContent = formatLuck(luckValue);
    card.classList.remove('cooling');
  }
  else {
    label.innerHTML = 'Luck <span class="luck-timer"></span>';

    val.textContent = '--';
    card.classList.remove('cooling');
  }
}

function startCooldown(seconds){
  cooldownUntil = Date.now() + seconds*1000;
  saveState('luckCooldownUntil', cooldownUntil);

  if(timerId) clearInterval(timerId);
  timerId = setInterval(()=>{
    if(getRemainingSec() <= 0){
      clearInterval(timerId);
      timerId = null;
      cooldownUntil = null;
      saveState('luckCooldownUntil', null);
      expired = true;
      updateLuckDisplay();
    } else {
      updateLuckDisplay();
    }
  }, 1000);
}

function rollLuckWeighted(){
  const options = [
    {value:-2, weight:10},
    {value:-1,  weight:10},
    {value:1,  weight:23},
    {value:2,  weight:23},
    {value:3,  weight:23},
    {value:4,  weight:10},
    {value:10, weight:1}
  ];
  const total = options.reduce((s,o)=>s+o.weight,0);
  let r = Math.random()*total;
  for(const o of options){
    if(r < o.weight) return o.value;
    r -= o.weight;
  }
  return options[options.length-1].value;
}

function pickNewLuck(){
  let newVal;
  do { newVal = rollLuckWeighted(); }
  while(newVal === lastLuck);
  lastLuck = newVal;
  saveState('luckLast', lastLuck);
  return newVal;
}

function activateLuck(){
  const rem = getRemainingSec();

  // STATE 2: cooling
  if(rem > 0) return;

  // STATE 3: expired → reset
  if(showing && expired){
    showing = false;
    expired = false;
    luckValue = null;
    saveState('luckShowing', false);
    saveState('Luck', null);
    updateLuckDisplay();
    return;
  }

  // STATE 1: ready → roll
  luckValue = pickNewLuck();
  saveState('Luck', luckValue);
  showing = true;
  expired = false;
  saveState('luckShowing', true);
  updateLuckDisplay();

  card.classList.add('flash');
  setTimeout(()=>card.classList.remove('flash'),400);

  startCooldown(99);
}

card.setAttribute('tabindex','0');

// 2025 Enhancement: Use same press-and-hold mechanism as other attributes
const activateLuckWithHold = () => {
  activateLuck();
};

// Apply touch handling to luck with press-and-hold animation
touchManager.attach(card, activateLuckWithHold, {
  ariaLabel: 'Luck attribute - Press and hold to activate',
  role: 'button'
});

updateLuckDisplay();

    } else {
    let valNum = stored;
    let lockout = false;

    function incrementAttribute() {
      if (lockout) return;
      valNum = (valNum + 1) % 10;
      val.textContent = String(valNum);
      saveState(name, valNum);

      if (limitAffectingAttrs.includes(name)) {
        updateAllBars();
        updateBottomStats();
      }

      card.classList.add('pulse');
      setTimeout(()=> card.classList.remove('pulse'), 420);

      lockout = true;
      setTimeout(()=> { lockout = false; }, 3000);
    }

    // Apply touch handling to regular attributes with 2025 enhancements
    touchManager.attach(card, incrementAttribute, {
      ariaLabel: `${name} attribute - Press and hold to level up`,
      role: 'button'
    });
  }
});

/* ========= Player name persistence and Enter handling ========= */
const playerNameInput = document.getElementById('playerName');
const existingName = loadState('playerName', '');
if(existingName) playerNameInput.value = existingName;
playerNameInput.addEventListener('keydown', (e)=>{
  if(e.key === 'Enter'){
    const nm = playerNameInput.value.trim();
    saveState('playerName', nm);
    playerNameInput.blur();
  }
});
playerNameInput.addEventListener('blur', ()=>{
  const nm = playerNameInput.value.trim();
  saveState('playerName', nm);
});

/* Reset button */
document.getElementById("resetBtn").onclick = () => {
  if (confirm("Are you sure you want to RESET ALL DATA?")) {
    localStorage.clear();
    location.reload();
  }
};

/* ========= Relationship System ========= */
const heartBtn = document.getElementById('heartBtn');
const relationshipOverlay = document.getElementById('relationshipOverlay');
const npcList = document.getElementById('npcList');
const addNpcBtn = document.getElementById('addNpcBtn');
const relationshipTitle = document.getElementById('relationshipTitle');

function updateRelationshipTitle() {
  const name = playerNameInput.value.trim() || 'Player';
  relationshipTitle.textContent = `${name}'s Relationships`;
}

updateRelationshipTitle();

let isRelationshipOpen = false;

function hasPlayerName() {
  return playerNameInput.value.trim().length > 0;
}

function updateHeartButtonState() {
  if (hasPlayerName()) {
    heartBtn.classList.remove('disabled');
  } else {
    heartBtn.classList.add('disabled');
  }
}

heartBtn.addEventListener('click', () => {
  if (!hasPlayerName()) {
    alert('Please enter a player name first!');
    return;
  }
  
  isRelationshipOpen = !isRelationshipOpen;
  if (isRelationshipOpen) {
    relationshipOverlay.classList.add('visible');
    heartBtn.classList.add('active');
    updateRelationshipTitle();
  } else {
    relationshipOverlay.classList.remove('visible');
    heartBtn.classList.remove('active');
  }
});

playerNameInput.addEventListener('input', () => {
  updateHeartButtonState();
  updateRelationshipTitle();
});
updateHeartButtonState();

const heartPath = 'M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z';

let npcs = loadState('npcs', []);

function saveNpcs() {
  saveState('npcs', npcs);
}

function getRelationshipStatus(hearts, npcName) {
  let filledCount = 0;
  for (let i = 0; i < hearts.length; i++) {
    if (hearts[i] === 1) {
      filledCount++;
    } else {
      break;
    }
  }

  if (npcName === "Naya" && filledCount === 7) {
    return "Best Friend";
  }

  const statusMap = {
    0: 'No Relationship',
    1: 'Familiar',
    2: 'Friendly',
    3: 'Friends',
    4: 'Accomplice',
    5: 'Companion',
    6: 'Partner',
    7: 'Lover'
  };
  
  return statusMap[filledCount] || 'No Relationship';
}

function updateNpcStatus(npcIndex) {
  if (npcs[npcIndex]) {
    npcs[npcIndex].status = getRelationshipStatus(
    npcs[npcIndex].hearts,
    npcs[npcIndex].name
    );
  }
}

const officialNpcImages = {
  "Hitomi":           "hearts/000.webp",
  "Tsubasa":          "hearts/001.webp",
  "Tress Bien":       "hearts/002.webp",
  "Dante Alimor":     "hearts/003.webp",
  "Evelynn":          "hearts/004.webp",
  "Flare vey Byornn": "hearts/005.webp",
  "Guy":              "hearts/006.webp",
  "Hector Havel":     "hearts/007.webp",
  "Jiu-lin Fan":      "hearts/008.webp",
  "Shang Tian":       "hearts/009.webp",
  "Marco":            "hearts/010.webp",
  "Lumiere":          "hearts/011.webp",
  "Anjali":           "hearts/012.webp",
  "Chinara Ekine":    "hearts/013.webp",
  "Ohm":              "hearts/014.webp",
  "Jon Quixote":      "hearts/015.webp",
  "Naya":             "hearts/016.webp",
  "Million Redgate":  "hearts/017.webp",
  "Captain Thiffany": "hearts/018.webp",
  "The Courier":      "hearts/019.webp",
  "Kleo Petra":       "hearts/030.webp",
  "Paarthi Lomedi":   "hearts/035.webp",
  "Qing Xi":          "hearts/036.webp",
  "Reeve S Basilisk": "hearts/037.webp",
  "Vincent Pererez":  "hearts/038.webp",
  "Taeonora 9C":      "hearts/039.webp"
}

function createNpcCard(npc, index) {
  const card = document.createElement('div');
  card.className = 'npc-card';
  card.dataset.index = index;

  const deleteBtn = document.createElement('button');
  deleteBtn.className = 'delete-npc-btn';
  deleteBtn.innerHTML = '<svg viewBox="0 0 24 24"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>';
  deleteBtn.addEventListener('click', () => {
    if (confirm('Delete this character?')) {
      if (npcs[index]) {
        npcs[index].official = false;
      }
      npcs.splice(index, 1);

      saveNpcs();
      renderNpcs();
      updateAddButtonVisibility();
    }
  });

  const imageDiv = document.createElement('div');
  imageDiv.className = 'npc-image' + (npc.image ? ' has-image' : '');
  
  if (npc.image) {
    const img = document.createElement('img');
    img.src = npc.image;
    imageDiv.appendChild(img);
  } else {
    imageDiv.innerHTML = '<svg viewBox="0 0 24 24"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>';
  }

  const fileInput = document.createElement('input');
  fileInput.type = 'file';
  fileInput.accept = 'image/*';
  fileInput.style.display = 'none';
  
  fileInput.addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (file) {
      if (!file.type.startsWith('image/')) {
        alert('Please select an image file.');
        return;
      }
      
      if (file.size > 6 * 2160 * 2160) {
        alert('Image file size must be less than 5MB.');
        return;
      }
      
      const reader = new FileReader();
      reader.onload = function(event) {
        npcs[index].image = event.target.result;
        saveNpcs();
        renderNpcs();
      };
      reader.readAsDataURL(file);
    }
  });

  imageDiv.addEventListener('click', () => {
    if (npcs[index].official) {
      alert("This is an official character. Their portrait cannot be changed.");
      return;
    }
    if (!npcs[index].name || npcs[index].name.trim().length === 0) {
      alert("Please enter a name before selecting an image.");
      return;
    }
    fileInput.click();
  });

  const infoDiv = document.createElement('div');
  infoDiv.className = 'npc-info';

  const nameInput = document.createElement('input');
  nameInput.className = 'npc-name';
  nameInput.placeholder = 'Character Name';
  nameInput.value = npc.name || '';
  const nameRow = document.createElement('div');
  nameRow.className = 'npc-name-row';

  const confirmBtn = document.createElement('button');
  confirmBtn.className = 'name-confirm-btn';
  confirmBtn.innerHTML = '<svg viewBox="0 0 24 24"><polyline points="20 6 9 17 4 12"/></svg>';
  confirmBtn.title = 'Save name';

  function saveName() {
    const oldName = npcs[index].name || '';
    const newName = nameInput.value.trim();

    npcs[index].name = newName;

    if (oldName.length === 0 && newName.length > 0) {
      npcs[index].hearts[0] = 1;
    } else if (newName.length === 0) {
      npcs[index].hearts = [0,0,0,0,0,0,0];
      npcs[index].image = null;
    }

    // 2025 Enhancement: Case-insensitive NPC name matching
    const findOfficialNpc = (searchName) => {
      const searchLower = searchName.toLowerCase();
      for (const [npcName, imagePath] of Object.entries(officialNpcImages)) {
        if (npcName.toLowerCase() === searchLower) {
          return { name: npcName, image: imagePath };
        }
      }
      return null;
    };
    
    const foundNpc = findOfficialNpc(newName);
    if (foundNpc) {
      npcs[index].image = foundNpc.image;
      npcs[index].official = true;
    } else {
      if (!npcs[index].official) {
        // Leave existing custom image unchanged
      }
      npcs[index].official = false;
    }

    updateNpcStatus(index);
    saveNpcs();
    renderNpcs();
  }

  nameInput.addEventListener('input', () => {
    const currentValue = nameInput.value.trim();
    const savedName = npcs[index].name || '';
    
    if (currentValue !== savedName && currentValue.length > 0) {
      confirmBtn.classList.add('visible');
    } else {
      confirmBtn.classList.remove('visible');
    }
  });

  nameInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      saveName();
      nameInput.blur();
    }
  });

  confirmBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    saveName();
  });

  nameRow.appendChild(nameInput);
  nameRow.appendChild(confirmBtn);

  const statusInput = document.createElement('div');
  statusInput.className = 'npc-status';
  statusInput.textContent = npc.status || 'No Relationship';

  const heartsDiv = document.createElement('div');
  heartsDiv.className = 'npc-hearts';

  if (!npc.hearts || npc.hearts.length !== 7) {
    npc.hearts = [0, 0, 0, 0, 0, 0, 0];
  }

  const hasName = npc.name && npc.name.trim().length > 0;
  if (hasName && npc.hearts[0] === 0) {
    npc.hearts[0] = 1;
    updateNpcStatus(index);
    saveNpcs();
  }

  if (!npc.status) {
    updateNpcStatus(index);
    saveNpcs();
  }

  for (let i = 0; i < 7; i++) {
    const heartIcon = document.createElement('div');
    heartIcon.className = 'heart-icon';
    heartIcon.dataset.heartIndex = i;
    
    const heartLevel = npc.hearts[i];
    
    if (heartLevel === 0) {
      heartIcon.classList.add('empty');
    } else {
      if (i === 0) {
        heartIcon.classList.add('filled-white');
      } else if (i >= 1 && i <= 2) {
        heartIcon.classList.add('filled-blue');
      } else if (i >= 3 && i <= 4) {
        heartIcon.classList.add('filled-purple');
      } else if (i >= 5 && i <= 6) {
        heartIcon.classList.add('filled-red');
      }
    }

    if (i === 6 && heartLevel === 1) {
      heartIcon.classList.add('pulse-heart');
    }

    const isLocked = !hasName || (i > 0 && npc.hearts[i - 1] === 0);
    if (isLocked) {
      heartIcon.classList.add('locked');
    }

    heartIcon.innerHTML = `<svg viewBox="0 0 24 24"><path d="${heartPath}"/></svg><div class="heart-number">${i + 1}</div>`;

    heartIcon.addEventListener('click', () => {
      if (!hasName) {
        alert('Please enter a character name first!');
        return;
      }

      if (i === 0) {
        return;
      }

      if (i > 0 && npc.hearts[i - 1] === 0) {
        return;
      }

      npcs[index].hearts[i] = npcs[index].hearts[i] === 0 ? 1 : 0;
      
      if (npcs[index].hearts[i] === 0) {
        for (let j = i + 1; j < 7; j++) {
          npcs[index].hearts[j] = 0;
        }
      }
      
      updateNpcStatus(index);
      
      saveNpcs();
      renderNpcs();
    });

    heartsDiv.appendChild(heartIcon);
  }

  infoDiv.appendChild(nameRow);
  infoDiv.appendChild(statusInput);
  infoDiv.appendChild(heartsDiv);

  card.appendChild(deleteBtn);
  card.appendChild(imageDiv);
  card.appendChild(fileInput);
  card.appendChild(infoDiv);

  return card;
}

function renderNpcs() {
  npcList.innerHTML = '';
  npcs.forEach((npc, index) => {
    npcList.appendChild(createNpcCard(npc, index));
  });
  updateAddButtonVisibility();
}

addNpcBtn.addEventListener('click', () => {
  if (npcs.length >= 3) {
    alert('Maximum of 3 characters allowed');
    return;
  }
  npcs.push({
    name: '',
    status: 'No Relationship',
    image: null,
    hearts: [0, 0, 0, 0, 0, 0, 0]
  });
  saveNpcs();
  renderNpcs();
  updateAddButtonVisibility();
});

function updateAddButtonVisibility() {
  if (npcs.length >= 3) {
    addNpcBtn.style.display = 'none';
  } else {
    addNpcBtn.style.display = 'flex';
  }
}

renderNpcs();
updateAddButtonVisibility();

updateBottomStats();

window.addEventListener('beforeunload', () => {
  iconManager.cleanup();
});

const artefacts = [
  "The Darkflame","The Wintergrace","The Bronze Ring of Smiles","The Wand",
  "The Pair and a Half","The Trickblade","The Fisherman's Flask",
  "Scathe's Memo Book","The Prismatic Glasses","The Coin"
];

const irises = [
  "Steady Sky Blue","Bravely Bold Gold","Radiant Emerald Green","Softly Strange Violet",
  "Feverspin Crimson","Amberbright Hazel","Honeydark Smoulder","Silver Slivers",
  "Otherworldly Odd","Absolute Cloying Dark"
];

const inventoryOverlay = document.getElementById('inventoryOverlay');
const inventoryBtn = document.getElementById('inventoryBtn');
const inventoryList = document.getElementById('inventoryList');
const addItemBtn = document.getElementById('addItemBtn');

let inventoryOpen = false;
let inventory = loadState('inventory', []);

function renderInventory() {
  inventoryList.innerHTML = '';
  inventory.forEach((item, i) => {
    const row = document.createElement('div');
    row.className = 'inventory-slot';

    const input = document.createElement('input');
    input.value = item || '';
    input.placeholder =
      i === 0 ? 'Soulbound Artefact' :
      i === 1 ? 'Iris' : 'Item';

    input.onblur = () => {
      inventory[i] = input.value.trim();
      saveState('inventory', inventory);
    };

    const clear = document.createElement('button');
    clear.className = 'clear-btn';
    clear.textContent = '×';
    clear.onclick = () => {
      inventory[i] = '';
      saveState('inventory', inventory);
      renderInventory();
    };

    row.append(input, clear);
    inventoryList.appendChild(row);
  });
}

inventoryBtn.onclick = () => {
  inventoryOpen = !inventoryOpen;
  inventoryOverlay.classList.toggle('visible', inventoryOpen);
  inventoryBtn.classList.toggle('active', inventoryOpen);
  renderInventory();
};

const addInventoryBtn = document.getElementById('addInventoryItem');

// 2025 Fix: Only enable "Add Item" when ALL existing slots are populated
function updateAddItemButtonState() {
  const maxSlots = Math.min(getMaxItemSlots(), 20);
  const currentCount = getCurrentItemCount();
  const totalSlots = getTotalItemSlots();
  const allSlotsPopulated = areAllSlotsPopulated();
  
  const canAddSlot = allSlotsPopulated && totalSlots < maxSlots && totalSlots < 20;
  
  // Update button state
  addInventoryBtn.disabled = !canAddSlot;
  addInventoryBtn.classList.toggle('disabled', !canAddSlot);
  
  // Update button text and tooltip
  if (!allSlotsPopulated) {
    addInventoryBtn.textContent = 'Fill Item Slots First';
    addInventoryBtn.title = `Fill all ${totalSlots} slot${totalSlots !== 1 ? 's' : ''} before adding more`;
  } else if (totalSlots >= maxSlots) {
    addInventoryBtn.textContent = 'Capacity Full';
    addInventoryBtn.title = `Maximum capacity reached (${maxSlots} slots). Level up Endurance to carry more.`;
  } else if (totalSlots >= 20) {
    addInventoryBtn.textContent = 'Hard Limit';
    addInventoryBtn.title = `Hard limit of 20 slots reached`;
  } else {
    addInventoryBtn.textContent = '+ Add Item Slot';
    addInventoryBtn.title = `Add new item slot (${currentCount}/${maxSlots} items, ${totalSlots} slots)`;
  }
  
  // Visual indicators
  if (!allSlotsPopulated) {
    addInventoryBtn.style.backgroundColor = 'rgba(255, 165, 0, 0.3)';
  } else if (totalSlots >= maxSlots || totalSlots >= 20) {
    addInventoryBtn.style.backgroundColor = 'rgba(255, 0, 0, 0.3)';
  } else {
    addInventoryBtn.style.backgroundColor = '';
  }
}

addInventoryBtn.onclick = () => {
  const maxSlots = Math.min(getMaxItemSlots(), 20);
  const currentCount = getCurrentItemCount();
  const totalSlots = getTotalItemSlots();
  const allSlotsPopulated = areAllSlotsPopulated();
  
  // Check if all slots are populated
  if (!allSlotsPopulated) {
    alert(`Please complete all ${totalSlots} existing slot${totalSlots !== 1 ? 's' : ''} before adding more items!`);
    return;
  }
  
  // Check capacity limits
  if (totalSlots >= maxSlots) {
    alert(`Inventory capacity reached! You can carry a maximum of ${maxSlots} items. Level up Endurance to increase capacity.`);
    return;
  }
  
  if (totalSlots >= 20) {
    alert('Hard limit of 20 inventory slots reached!');
    return;
  }
  
  // Add new slot
  inventory.push({});
  saveState('inventory', inventory);
  renderInventory();
  updateAddItemButtonState(); // Refresh button state
};

if (inventory.length === 0) {
  inventory = ['', '']; // artefact + iris
  saveState('inventory', inventory);
}
const inventoryDB = {
  artefacts: {
    "The Darkflame": {
      type: "Legendary Hero Artefact — Treasure",
      description: `Scales with arcane or tinge.
Immune to high temperatures, burns, inflammation, and fever.
Grants fire and smoke magic & skills.
Sacrifice things to flame to gain essence.`,
      image: "cards/fronts/110.webp"
    },
    "The Wintergrace": {
      type: "Legendary Hero Artefact — Treasure",
      description: `Scales with arcane or tinge.
Immune to cold temperatures, frostbite, and hypothermia.
Grants ice and frost magic & skills.
Recharges essence in moonlight.`,
      image: "cards/fronts/111.webp"
    },
    "The Bronze Ring of Smiles": {
      type: "Legendary Hero Artefact — Treasure",
      description: `Grants charisma, illusion,
deception, intimidation.
Grants gaze magic & skills.
Regain essence from relationships.`,
      image: "cards/fronts/112.webp"
    },
    "The Wand": {
      type: "Legendary Hero Artefact — Treasure",
      description: `When resolving tinge, add arcane.
Essence: Choose one spell: It can only be used by the wand, all costs are 1.`,
      image: "cards/fronts/113.webp"
    },
    "The Pair and a Half": {
      type: "Legendary Hero Artefact — Treasure",
      description: `Scales with skill.
Add one to skill when resolving.
The cloth is immune and impervious.
Mutes sounds made by the bearer.
Grants bizarre skills.`,
      image: "cards/fronts/114.webp"
    },
    "The Trickblade": {
      type: "Legendary Hero Artefact — Treasure",
      description: `Scales with strength.
Add one strength when resolving.
Truestrike when thrust or thrown.
Grants bizarre skills.`,
      image: "cards/fronts/115.webp"
    },
    "The Fisherman's Flask": {
      type: "Legendary Hero Artefact — Treasure",
      description: `When resolving: add two arcane.
Produces any substance as poured into the maw.
Grants bizarre magic.
When consuming potions, elixirs, and drinks, regain essence.`,
      image: "cards/fronts/116.webp"
    },
    "Scathe's Memo Book": {
      type: "Legendary Hero Artefact — Treasure",
      description: `Questions, predictions, and histories can be written on the page;
spells cast this way ignore requirements.
Once locked, pages appear anew.`,
      image: "cards/fronts/117.webp"
    },
    "The Prismatic Glasses": {
      type: "Legendary Hero Artefact — Treasure",
      description: `When resolving: add two tinge.
Can detect attunement and prowess, and sense the unreadable.
Grants futuresight and scan.`,
      image: "cards/fronts/118.webp"
    },
    "The Coin": {
      type: "Legendary Hero Artefact — Treasure",
      description: `Gain luck.
When resolving situations, add luck.
Anyone else holding the coin is also lucky.
When given as tender; a new coin may be found somewhere...
Grants mundane magic & skills.`,
      image: "cards/fronts/119.webp"
    }
  },

  irises: {
    "Steady Sky Blue": {
      type: "Eyes — Iris",
      description: `When affected by any real or artificial light, regain one mana and gain favour after casting.`,
      image: "cards/fronts/040.webp"
    },
    "Bravely Bold Gold": {
      type: "Eyes — Iris",
      description: `Resist dread, panic, terror.
In a pinch, cast spells or act until a resource pool is completely empty.`,
      image: "cards/fronts/043.webp"
    },
    "Radiant Emerald Green": {
      type: "Eyes — Iris",
      description: `Occasionally, do not trigger tap.
You may pay energy instead of life.`,
      image: "cards/fronts/046.webp"
    },
    "Softly Strange Violet": {
      type: "Eyes — Iris",
      description: `Double your spell limit.
If blessed, +1 to spell resolves.`,
      image: "cards/fronts/049.webp"
    },
    "Feverspin Crimson": {
      type: "Eyes — Iris",
      description: `After casting or combining three or more spells, gain empower.
Gain quick after using empower.`,
      image: "cards/fronts/052.webp"
    },
    "Amberbright Hazel": {
      type: "Eyes — Iris",
      description: `Resist moonworm effects.
Tap: Act as if touched by dawn.
Untap: Trigger a madness effect.`,
      image: "cards/fronts/055.webp"
    },
    "Honeydark Smoulder": {
      type: "Eyes — Iris",
      description: `After performing a physical action, the next spell gains favour.
After performing any spell, the next physical action gains favour.`,
      image: "cards/fronts/058.webp"
    },
    "Silver Slivers": {
      type: "Eyes — Iris",
      description: `Stop time:
Gain quick, and act, then tap.
At dawn, forfeit mana or power and then untap.`,
      image: "cards/fronts/061.webp"
    },
    "Otherworldly Odd": {
      type: "Eyes — Iris",
      description: `At the start of your turn, you must forget one spell, then gain another.
You can only possess five spells of any kind.`,
      image: "cards/fronts/064.webp"
    },
    "Absolute Cloying Dark": {
      type: "Eyes — Iris",
      description: `If you have any madness spell, succeed madness resolves.
If you have the highest madness, ignore night effects.`,
      image: "cards/fronts/067.webp"
    }
  },

  items: {
    "Basic Buckler": {
      type: "Basic Artefact — Equipment",
      description: `Equip: Strength 2.
Gain armour 1.
(reduce incoming damage by one)`,
      image: "cards/fronts/120.webp"
    },
    "Basic Shortsword": {
      type: "Basic Artefact — Equipment",
      description: `Equip: Strength 1.
When melee attacking using,
add 1 to resolves or damage.`,
      image: "cards/fronts/121.webp"
    },
    "Crested Shield": {
      type: "Basic Artefact — Equipment",
      description: `Equip: Strength 3.
Pay stamina: Gain shield 2.
(absorb two damage)
Skill 3: Pay stamina: Parry incoming strike.`,
      image: "cards/fronts/122.webp"
    },
    "Simple Shortbow": {
      type: "Basic Artefact — Equipment",
      description: `Equip: Skill 1.
Pay stamina: Deal 2 pierce damage.
Skill 3: Double damage and range.`,
      image: "cards/fronts/123.webp"
    },
    "Legionnaire Crossbow": {
      type: "Artefact — Equipment",
      description: `Equip: Skill 2.
Pay stamina then channel to charge your shot: Deal 3 pierce damage.
Strength 5: You can now shoot twice.`,
      image: "cards/fronts/124.webp"
    },
    "Crysk Knife": {
      type: "Artefact — Equipment",
      description: `Equip: Skill 1.
Pay stamina: After successful attack, prevent target from casting a spell.
Skill 3: Also add 3 pierce damage.`,
      image: "cards/fronts/125.webp"
    },
    "Whispering Shield": {
      type: "Artefact — Equipment",
      description: `Equip: Strength 3.
Pay stamina: Gain shield 3.
(absorb three damage)
Skill 3: Pay stamina: Parry incoming magic.`,
      image: "cards/fronts/126.webp"
    },
    "Twisted Metal Arm": {
      type: "Artefact — Equipment",
      description: `Equip: Skill 3.
When resolving strength, add 1.
Pay stamina: Griplock an object.`,
      image: "cards/fronts/127.webp"
    },
    "Intricate Metal Arm": {
      type: "Artefact — Equipment",
      description: `Equip: Skill 3.
Pay empower: Electrify and magnetize arm.
Pay stamina: Shock and paralyze attacker.
Resist burn and freeze.`,
      image: "cards/fronts/128.webp"
    },
    "Arcanite Mining Gauntlet": {
      type: "Artefact — Equipment",
      description: `Equip: Strength 4.
Pay stamina: Deal damage and stun, striking with devastating force.
Mastery 3: Socket a soulgem.`,
      image: "cards/fronts/129.webp"
    },
    "Arcanite Slingshot": {
      type: "Artefact — Arcane Equipment",
      description: `Pay energy: Shoot a pebble of arcane energy. Activate arcane objects.
Mastery 3: Deal 1 electric damage.`,
      image: "cards/fronts/130.webp"
    },
    "Arcane Gemsetting Tool": {
      type: "Artefact — Arcane Equipment",
      description: `Pay two stamina, two energy, and 1 of any resource:
Mastery 2: Install a soulgem.
Mastery 5: Remove a soulgem.
Arcane 13: Carve a soulgem socket.`,
      image: "cards/fronts/131.webp"
    },
    "Arcanite Battery Pack": {
      type: "Artefact — Arcane Equipment",
      description: `When socketed with a soulgem:
Provide required electric electricity to power devices, tools, and other equipment.`,
      image: "cards/fronts/132.webp"
    },
    "Arcanite Firearm": {
      type: "Artefact — Arcane Equipment",
      description: `Pay three energy: Shoot a bolt of arcane energy. Activate arcane objects, or deal damage equal to your arcane.
Requires Skill to aim accurately...`,
      image: "cards/fronts/133.webp"
    },
    "Arcanite Revolver": {
      type: "Artefact — Arcane Equipment",
      description: `Pay one energy: Deal damage equal to your mastery; then resolve (dice) d6:
Shoot again for each unique result, otherwise tap. Pay 6 of any resource to reload and untap.
Requires Strength for the recoil.`,
      image: "cards/fronts/134.webp"
    },
    "Moontooth": {
      type: "Artefact — Arcane Equipment",
      description: `Mastery 4: Swings blast seawater.
Strength 6: All strikes push targets away.`,
      image: "cards/fronts/135.webp"
    },
    "Saphir": {
      type: "Artefact — Arcane Equipment",
      description: `Mastery 2: Strikes gain quick.
Skill 3: Strikes gain triplestrike.`,
      image: "cards/fronts/136.webp"
    },
    "Caladlo": {
      type: "Artefact — Equipment",
      description: `If target has armour, gain swift and doublestrike.
Strength & Skill 3: Remove and prevent target's shields.`,
      image: "cards/fronts/137.webp"
    },
    "Matsubazue": {
      type: "Artefact — Equipment",
      description: `Channel to focus your mind and build strength:
Inflict concussive force or break bones instead of inflicting damage.
Skill 6: You may counter-attack any weapon-based attack.`,
      image: "cards/fronts/138.webp"
    },
    "Woven Wreath": {
      type: "Artefact — Equipment",
      description: `You feel confident, pretty.
Anyone nearby winces with pain or starts crying when thinking of you negatively.`,
      image: "cards/fronts/139.webp"
    },
    "Cozy Scarf": {
      type: "Artefact — Equipment",
      description: `Seems to fold infinitely.
Stretches unnaturally long. Can conceal items within, but the weight cannot be ignored.`,
      image: "cards/fronts/140.webp"
    },
    "Clamping Ankle Bracers": {
      type: "Artefact — Equipment",
      description: `Allows movement, unimpeded.
Easily jump higher and farther.
Contains one empty soulgem socket.`,
      image: "cards/fronts/141.webp"
    },
    "Strand-Type Carry Device": {
      type: "Artefact — Arcane Equipment",
      description: `Pay stamina: Allocate items to the device.
Do not lose stamina when moving, carrying, or running.
Items gain indestructible.`,
      image: "cards/fronts/142.webp"
    },
    "Strand-Type Cuff Device": {
      type: "Artefact — Arcane Equipment",
      description: `Pay three energy: Switch places with another bearer, you both gain 1 shield. (Absorb 1 damage)
Mastery 2: Awaken soulgem.`,
      image: "cards/fronts/143.webp"
    },
    "Strand-Type Choker Device": {
      type: "Artefact — Arcane Equipment",
      description: `Pay energy: Gain favour momentarily.
Mastery 3: Awaken soulgem.`,
      image: "cards/fronts/145.webp"
    },
    "Catscratch Medallion": {
      type: "Artefact — Equipment",
      description: `You are more susceptible to dread, panic, horrify, and the ethereal.
Detect bone charms, traps, and understand hexes and curses.`,
      image: "cards/fronts/146.webp"
    },
    "Pegasus Soulgem Medallion": {
      type: "Legendary Artefact — Soulgem",
      description: `When held, provides boosts to any movement action. Holding your breath while falling slows descent.`,
      image: "cards/fronts/147.webp"
    },
    "Mercurial Opal": {
      type: "Legendary Artefact — Soulgem",
      description: `For each resource pool at maximum, gain +1. When socketed into a tool, gear, device, or machine, energizes indefinitely.`,
      image: "cards/fronts/148.webp"
    },
    "Cascading Crystal": {
      type: "Soulgem — Powerstone",
      description: `After receiving any force of physical impact, user can unleash equal force from the gem. When socketed into a weapon or tool, object becomes extremely bouncy.`,
      image: "cards/fronts/149.webp"
    },
    "Spiderflame Diamond": {
      type: "Soulgem — Powerstone",
      description: `Remaining still, eyes closed, the user can detect movement further and further away. When socketed, object becomes magnetic at-will.`,
      image: "cards/fronts/150.webp"
    },
    "Abyssal Onyx": {
      type: "Soulgem — Powerstone",
      description: `Emits a light visible only to its user. Can devour artificial light. When socketed, repels liquids, dust, and other small particles.`,
      image: "cards/fronts/151.webp"
    },
    "Sharp Garnet": {
      type: "Soulgem — Powerstone",
      description: `All types of force exerted gain sharp and pierce. When socketed into a tool, gear, or wearable equipment, contacting a critical weakpoint causes target to shatter into dust.`,
      image: "cards/fronts/152.webp"
    },
    "Sakura Ruby": {
      type: "Soulgem — Powerstone",
      description: `Repeated actions gain +1.
When socketed, energizes tools and weapons to resonate at extreme speeds.`,
      image: "cards/fronts/153.webp"
    },
    "Cosmic Pearl": {
      type: "Soulgem — Powerstone",
      description: `If a spell or action would cost more than you have, use it then empty that resource pool. When socketed, energizes other nearby things.`,
      image: "cards/fronts/154.webp"
    },
    "Redsky Pearl": {
      type: "Soulgem — Powerstone",
      description: `When in darkness, untouched by any light, gain one empower if you have none. When socketed, object cannot freeze nor become wet; object maintains temperature.`,
      image: "cards/fronts/155.webp"
    },
    "Coiling Amethyst": {
      type: "Soulgem — Powerstone",
      description: `Onlookers may become anxious. Gain favour when near a deep body of water or when resting. When socketed, object cannot fall apart.`,
      image: "cards/fronts/156.webp"
    },
    "Folded Moss": {
      type: "Soulgem — Powerstone",
      description: `Eating spiced food can bestow or remove curses and blessings. When socketed, object becomes squishy.`,
      image: "cards/fronts/157.webp"
    },
    "Sharp Sapphire": {
      type: "Soulgem — Powerstone",
      description: `When physically attacking, you may resolve again. When socketed, if object is a weapon, inflict terror on targets if you miss.`,
      image: "cards/fronts/158.webp"
    },
    "Emanating Garnet": {
      type: "Soulgem — Powerstone",
      description: `When physically attacking, add endurance or potency. When socketed, if object is a weapon, deal crush and strike damage instead.`,
      image: "cards/fronts/159.webp"
    },
    "Sunsmoke Jade": {
      type: "Soulgem — Powerstone",
      description: `Unlock true power when socketed.`,
      image: "cards/fronts/160.webp"
    },
    "Ball Ruby": {
      type: "Soulgem — Powerstone",
      description: `When resting, you may reduce madness instead of recovering life and stamina. When socketed, object feels almost weightless.`,
      image: "cards/fronts/161.webp"
    },
    "Mesmer Diamond": {
      type: "Soulgem — Powerstone",
      description: `Wonderous tendrils of ivory are hewn beneath the skin.
If you would lose madness, you may instead gain 1 of any resource.
When socketed, puppet object freely.`,
      image: "cards/fronts/162.webp"
    },
    "Hollow Prism": {
      type: "Soulgem — Powerstone",
      description: `Tap: Store an amount of mana or energy.
Untap: Release mana or energy, then gain madness.
When socketed, you may command object to return to you.`,
      image: "cards/fronts/163.webp"
    },
    "Blooming Seaglass": {
      type: "Soulgem — Powerstone",
      description: `During any encounter, opponent gains slow and cannot gain favour. Attracts beasts, mellowing their demeanor.
When socketed into a non-weapon, fascinates beasts.`,
      image: "cards/fronts/164.webp"
    },
    "Starstone": {
      type: "Soulgem — Powerstone",
      description: `Resist dread, panic, terror. Repels wormridden things. Kills nearby airborne infectious materials.
Socketed objects become suspended mid-air when released.`,
      image: "cards/fronts/165.webp"
    },
    "Starglass": {
      type: "Soulgem — Powerstone",
      description: `Repeat any spell cast by another if the cost is less than your Mastery.
When socketed, object whispers warnings and rumours.`,
      image: "cards/fronts/166.webp"
    },
    "Bicoded Twist": {
      type: "Soulgem — Powerstone",
      description: `Tap: Whenever you pay exactly two different costs, add 2 to values.
Whenever you gain or lose madness, you may untap. Cannot be socketed.`,
      image: "cards/fronts/167.webp"
    },
    "Wet Deeprock": {
      type: "Soulgem — Powerstone",
      description: `After taking any action, you may channel and gain phantom momentum: A lifelike image will repeat that action. Continue channelling to manipulate the image. Socketed object becomes heavy and salty.`,
      image: "cards/fronts/168.webp"
    },
    "Polar Crystal": {
      type: "Soulgem — Powerstone",
      description: `Can store and release electricity.
When socketed, remove requirements, costs, tap effects and untap effects from object.`,
      image: "cards/fronts/169.webp"
    },
    "Potion of Healing": {
      type: "Item — Potion",
      description: `Regain 3 life.
You cannot gain beyond maximum.`,
      image: "cards/fronts/170.webp"
    },
    "Potion of Refreshment": {
      type: "Item — Potion",
      description: `Regain 2 stamina.
You cannot gain beyond maximum.`,
      image: "cards/fronts/174.webp"
    },
    "Potion of Potency": {
      type: "Item — Potion",
      description: `Regain empower.
Fragile.
Flammable.`,
      image: "cards/fronts/178.webp"
    },
    "Potion of Sunshine": {
      type: "Item — Potion",
      description: `Regain mana. Fragile.
Tinge 8: Regain one more mana.
Tinge 12: Tastes pleasant, abating any madness effect.`,
      image: "cards/fronts/182.webp"
    },
    "Potion of Sparkling Water": {
      type: "Item — Potion",
      description: `Fragile.
Gain Arcane Touch, duration is equal to your Endurance.
Arcane 7: Regain 2 energy.`,
      image: "cards/fronts/186.webp"
    },
    "Potion of Dreaming": {
      type: "Item — Potion",
      description: `Fragile. Choose one:
Sleep briefly, then awaken;
or
Calm your nerves, remove 3 madness.`,
      image: "cards/fronts/190.webp"
    },
    "Murky Elixir": {
      type: "Item — Elixir",
      description: `Double any healing effect.
If you become poisoned or a similar status effect, reduce that duration to 1.
You are more easily surprised, startled, or intimidated.`,
      image: "cards/fronts/193.webp"
    },
    "Beastblood Elixir": {
      type: "Item — Elixir",
      description: `Improves chances of befriending or intimidating some beasts.
Avid drinkers claim further effects.
You smell like wet dog, or vanilla?`,
      image: "cards/fronts/196.webp"
    },
    "Humeblood Elixir": {
      type: "Item — Elixir",
      description: `An inky, fizzy cola. Smells of copper with a hint of bacon. Caffeinates when hot; inebriates when cold.`,
      image: "cards/fronts/199.webp"
    },
    "Vial of Lunacy": {
      type: "Item — Elixir",
      description: `Duration is equal to your madness.
Combine and. Cruel energies empower your demeanor.
Activate one madness effect.`,
      image: "cards/fronts/201.webp"
    },
    "Vial of Volpe": {
      type: "Item — Elixir",
      description: `A wonderful flavour tickles your tongue. Resolve (dice) d20: From 1~10, you may regain that much life or stamina or one empower; if you roll 11~20, gain madness.`,
      image: "cards/fronts/204.webp"
    },
    "Heady Elixir": {
      type: "Item — Elixir",
      description: `Bestows a heady feeling for a time.
The imbiber experiences a sense of euphoria, becoming immune to negative moods and intimidation, but susceptible to seduction.`,
      image: "cards/fronts/207.webp"
    },
    "Sparkwine": {
      type: "Item — Elixir",
      description: `Applying to the skin, protects and remedies sunburns. When imbibed, causes a heady excitatory buzzing.
Consecutive drinks increase the effect but reduce duration...`,
      image: "cards/fronts/210.webp"
    },
    "Woebane Elixir": {
      type: "Item — Elixir",
      description: `Cherry smoke replaces your breath: React calmly to the world around you, act as if your soul has just awoken from a catnap.
Duration is equal to your current madness.`,
      image: "cards/fronts/213.webp"
    },
    "Swirling Cream": {
      type: "Item — Drink",
      description: `Minty sweetness coats your mouth, lips, and tongue: Soothe your nerves.
Abate an allergic reaction or become ridiculously intoxicated.`,
      image: "cards/fronts/216.webp"
    },
    "Sunset Sap": {
      type: "Item — Drink",
      description: `Chewey, jellylike substance popular among children and their parents.
Innocuous. Pernicious. Wonderful.`,
      image: "cards/fronts/219.webp"
    },
    "Lilypad Rime": {
      type: "Item — Drink",
      description: `Prized by brewers and mixers.
Some report a chilling effect.
Inebriates for a prolonged time, usually as a matter of one's madness.`,
      image: "cards/fronts/222.webp"
    },
    "Honeyseed Soma": {
      type: "Item — Drink",
      description: `Often taken as a remedy for nausea, headaches, stomach aches, pain, and dizziness. Results in a bouncy and delightfully comfortable mood.`,
      image: "cards/fronts/225.webp"
    }
  }
};

function createInventoryCard(index, slotType, data = {}) {
  const hasImage = data.image ? 'has-image' : '';
  const isLocked = data.locked ? 'locked' : '';
  const imgContent = data.image 
    ? `<img src="${data.image}" alt="${data.name || 'Item'}" />`
    : `<svg viewBox="0 0 24 24"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>`;
  
  return `
  <div class="inventory-item" data-index="${index}" data-slot="${slotType}">
    <div class="inv-image ${hasImage}">${imgContent}</div>
    
    <div class="inv-info">
      <input class="inv-name ${isLocked}" 
             placeholder="${placeholderForSlot(slotType)}" 
             value="${data.name || ''}" 
             ${isLocked ? 'readonly' : ''} />
      <div class="inv-type">${data.type || slotTypeLabel(slotType)}</div>
      <div class="inv-description">${data.description || '—'}</div>
    </div>
    
    <button class="inv-confirm-btn">
      <svg viewBox="0 0 24 24"><polyline points="20 6 9 17 4 12"/></svg>
    </button>
    <button class="inv-delete-btn">
      <svg viewBox="0 0 24 24"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
    </button>
  </div>`;
}

function placeholderForSlot(slot) {
  if (slot === 'artefact') return 'Soulbound Artefact';
  if (slot === 'iris') return 'Iris';
  return 'Item';
}

function slotTypeLabel(slot) {
  if (slot === 'artefact') return 'Soulbound Artefact';
  if (slot === 'iris') return 'Iris';
  return 'Item';
}

// Helper: Check if item type is consumable
function isConsumable(type) {
  if (!type) return false;
  const t = type.toLowerCase();
  return t.includes('potion') || t.includes('elixir') || t.includes('drink');
}

// Helper: Check if item grants carry bonus
const CARRY_BONUS_ITEMS = ['Cozy Scarf', 'Clamping Ankle Bracers', 'Strand-Type Carry Device'];

function hasCarryBonusItem() {
  return inventory.some(item => item?.name && CARRY_BONUS_ITEMS.includes(item.name));
}

// Calculate max carry capacity (items only, not artefact/iris)
function getMaxItemSlots() {
  const endurance = Number(loadState('Endurance', 0)) || 0;
  let base = 3 + endurance;
  if (hasCarryBonusItem()) base += 8;
  return base;
}

// Count current items (excluding artefact/iris slots)
function getCurrentItemCount() {
  return inventory.slice(2).filter(item => item?.name).length;
}

// 2025 Enhancement: Check if ALL item slots are populated
function areAllSlotsPopulated() {
  const itemSlots = inventory.slice(2); // Get all item slots
  return itemSlots.length === 0 || itemSlots.every(slot => slot?.name && slot.name.trim() !== '');
}

// Get total number of item slots (including empty ones)
function getTotalItemSlots() {
  return inventory.slice(2).length;
}

// Check if item already exists (for uniqueness), excluding a specific index
function itemAlreadyExists(name, excludeIndex = -1) {
  return inventory.some((item, i) => i !== excludeIndex && item?.name === name);
}

// 2025 Enhancement: Case-insensitive duplicate checking
function itemAlreadyExistsCaseInsensitive(name, excludeIndex = -1) {
  const searchLower = name.toLowerCase();
  return inventory.some((item, i) => i !== excludeIndex && item?.name?.toLowerCase() === searchLower);
}

function validateInventoryName(name, slot, excludeIndex = -1) {
  if (!name || name.trim().length === 0) return null;
  const trimmed = name.trim();
  
  // 2025 Enhancement: Case-insensitive matching for user convenience
  const findCaseInsensitive = (obj, searchName) => {
    const searchLower = searchName.toLowerCase();
    for (const [key, value] of Object.entries(obj)) {
      if (key.toLowerCase() === searchLower) {
        return { key, data: value };
      }
    }
    return null;
  };
  
  // Get item data with case-insensitive matching
  let itemData = null;
  let foundItem = null;
  
  if (slot === 'artefact') {
    foundItem = findCaseInsensitive(inventoryDB.artefacts, trimmed);
    if (foundItem) {
      itemData = { name: foundItem.key, ...foundItem.data, locked: true };
    }
  } else if (slot === 'iris') {
    foundItem = findCaseInsensitive(inventoryDB.irises, trimmed);
    if (foundItem) {
      itemData = { name: foundItem.key, ...foundItem.data, locked: true };
    }
  } else if (slot === 'item') {
    foundItem = findCaseInsensitive(inventoryDB.items, trimmed);
    if (foundItem) {
      itemData = { name: foundItem.key, ...foundItem.data, locked: true };
    }
  }
  
  if (!itemData) {
    // Custom item
    itemData = { name: trimmed, type: slotTypeLabel(slot), description: '—', locked: false };
  }
  
  // Check uniqueness (allow duplicates only for consumables) - case insensitive
  if (itemData && itemAlreadyExistsCaseInsensitive(trimmed, excludeIndex) && !isConsumable(itemData.type)) {
    alert(`You already have "${trimmed}" in your inventory. Non-consumable items must be unique.`);
    return null;
  }
  
  return itemData;
}

function bindInventoryEvents() {
  document.querySelectorAll('.inventory-item').forEach(card => {
    const index = +card.dataset.index;
    const slot = card.dataset.slot;
    const nameInput = card.querySelector('.inv-name');
    const confirmBtn = card.querySelector('.inv-confirm-btn');
    const deleteBtn = card.querySelector('.inv-delete-btn');
    const imageDiv = card.querySelector('.inv-image');
    
    // Show confirm button when name changes
    nameInput.addEventListener('input', () => {
      const currentValue = nameInput.value.trim();
      const savedName = inventory[index]?.name || '';
      if (currentValue !== savedName && currentValue.length > 0) {
        confirmBtn.classList.add('visible');
      } else {
        confirmBtn.classList.remove('visible');
      }
    });
    
    // Save on Enter
    nameInput.addEventListener('keydown', e => {
      if (e.key === 'Enter') {
        e.preventDefault();
        saveInventoryItem(index, slot, nameInput.value.trim());
        nameInput.blur();
      }
    });
    
    // Confirm button click
    confirmBtn.onclick = () => {
      saveInventoryItem(index, slot, nameInput.value.trim());
    };
    
    // Delete button with confirmation dialog
    deleteBtn.onclick = () => {
      const item = inventory[index];
      const itemName = item?.name || 'this item';
      
      if (confirm(`Discard "${itemName}"? This action cannot be undone.`)) {
        // Don't delete artefact/iris slots, just clear them
        if (index < 2) {
          inventory[index] = {};
        } else {
          inventory.splice(index, 1);
        }
        saveState('inventory', inventory);
        renderInventory();
      }
    };
    
    // Image click: Consume prompt for potions/elixirs/drinks
    imageDiv.onclick = () => {
      const item = inventory[index];
      if (!item?.name) return;
      
      if (isConsumable(item.type)) {
        if (confirm(`Consume "${item.name}"?`)) {
          // Remove the consumed item
          if (index < 2) {
            inventory[index] = {};
          } else {
            inventory.splice(index, 1);
          }
          saveState('inventory', inventory);
          renderInventory();
        }
      }
      // Non-consumables: could add image upload here
    };
  });
}

function saveInventoryItem(index, slot, name) {
  const result = validateInventoryName(name, slot, index);
  if (!result) {
    // Don't clear if validation failed due to duplicate
    if (!name || name.trim().length === 0) {
      inventory[index] = {};
    }
  } else {
    inventory[index] = result;
  }
  saveState('inventory', inventory);
  renderInventory();
}

// Override renderInventory to use cards
renderInventory = function() {
  inventoryList.innerHTML = '';
  
  // Ensure minimum slots
  while (inventory.length < 2) {
    inventory.push({});
  }
  
  // Update capacity display
  const capacityEl = document.getElementById('inventoryCapacity');
  if (capacityEl) {
    const current = getCurrentItemCount();
    const max = getMaxItemSlots();
    const isFull = current >= max;
    capacityEl.innerHTML = `Items: <span class="${isFull ? 'capacity-full' : ''}">${current} / ${max}</span>`;
  }
  
  inventory.forEach((item, i) => {
    const slotType = i === 0 ? 'artefact' : i === 1 ? 'iris' : 'item';
    const data = typeof item === 'object' ? item : {};
    inventoryList.innerHTML += createInventoryCard(i, slotType, data);
  });
  
  bindInventoryEvents();
  updateAddItemButtonState();
};

</script>
</body>
</html>