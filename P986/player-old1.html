<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Player Tracker — Player</title>

<style>
  :root{
    --bg:#121212;
    --card:#1f1f1f;
    --muted:#9aa3ad;
    --accent-purple: rgba(106,27,154,0.22);
    --gold: #D4AF37;
    --blue-cool:#66ccff;
    --glass: rgba(255,255,255,0.04);
    --heart-white: #ffffff;
    --heart-blue: #4da6ff;
    --heart-purple: #9b59b6;
    --heart-red: #ff8fa3;
    --scarlet-pink: #ff8fa3;
  }

  html,body{height:100%;margin:0;}
  body{
    margin:0;
    min-height:100%;
    font-family: "Inter", "Segoe UI", Arial, sans-serif;
    background: linear-gradient(180deg,#0f0f12 0%, #141417 60%);
    color:#e9eef6;
    -webkit-font-smoothing:antialiased;
    -moz-osx-font-smoothing:grayscale;
  }

  .wrap{
    max-width:900px;
    margin:14px auto;
    padding:16px;
  }

  /* Player name */
  #playerName{
    width:100%;
    display:block;
    font-size:2.0rem;
    text-align:center;
    background:transparent;
    color: #fff;
    border: 0;
    outline:0;
    padding:8px 4px;
    margin-bottom:14px;
  }
  #playerName::placeholder{ color: rgba(255,255,255,0.25); }

  /* ---------- Bars layout: grid 2 cols on wide, 1 col + reorder on small ---------- */
  .bars {
    display:grid;
    grid-template-columns: repeat(2, minmax(220px, 1fr));
    gap:20px;
    margin-bottom:16px;
  }

  @media (max-width: 720px) {
    .bars { grid-template-columns: 1fr; }

    .bar-card[data-key="life"]     { order: 1; }
    .bar-card[data-key="stamina"]  { order: 2; }
    .bar-card[data-key="empower"]  { order: 3; }
    .bar-card[data-key="mana"]     { order: 4; }
    .bar-card[data-key="energy"]   { order: 5; }
    .bar-card[data-key="coalesce"] { order: 6; }
  }

  @media (min-width: 721px) {
    .bar-card { order: initial; }
  }

  .bar-card{
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border-radius:20px;
    padding:13px 16px;
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:20px;
    box-shadow: 0 6px 18px rgba(0,0,0,0.6);
    transition: transform .14s ease, box-shadow .14s ease;
  }
  .bar-card:hover{ transform: translateY(-2px); box-shadow: 0 20px 30px rgba(0,0,0,0.7); }

  .bar-left{
    display:flex;
    align-items:center;
    gap:14px;
    min-width: 0;
  }

  .bar-dot{
    width: clamp(22px, 2.5vw, 34px);
    height: clamp(22px, 2.5vw, 34px);
    border-radius:50%;
    box-shadow: 0 2px 6px rgba(0,0,0,0.6), inset 0 -1px 0 rgba(255,255,255,0.05);
    flex: 0 0 auto;
  }
  .dot-life{ background: linear-gradient(180deg,#5fd08f,#2fb96b); }
  .dot-stamina{ background: linear-gradient(180deg,#6fb8ff,#2b74ff); }
  .dot-mana{ background: linear-gradient(180deg,#ffc46b,#ff9a2b); }
  .dot-energy{ background: linear-gradient(180deg,#6ff0ff,#13b6ff); }
  .dot-empower{ background: linear-gradient(180deg,#ff4d4d,#DC143C); }
  .dot-coalesce{ background: linear-gradient(180deg,#f5f7fa,#d9dde6); border:1px solid rgba(255,255,255,0.06); }

  .bar-label{ font-weight:600; font-size:1.38rem; color:#f1f5fb; white-space:nowrap; }
  .bar-controls{ display:flex; align-items:center; gap:8px; }

  .bar-value{
    width:80px;
    text-align:center;
    font-weight:700;
    font-size:1.10rem;
    color:#ffffff;
    font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
  }

  .btn {
    -webkit-appearance:none;
    appearance:none;
    border:0;
    background: rgba(255,255,255,0.06);
    color: #fff;
    padding:6px 10px;
    border-radius:8px;
    cursor:pointer;
    font-weight:700;
    transition: transform .12s ease, background .12s ease, box-shadow .12s ease;
  }
  .btn:active{ transform: scale(.97); }
  .btn:focus{ outline:none; box-shadow:0 0 0 3px rgba(102,204,255,0.12); }
  .btn:disabled{ opacity: 0.3; cursor: not-allowed; }
  .btn:hover { background: #ff00ff; }

  /* Attributes grid */
  .attributes{
    display:grid;
    grid-template-columns: repeat(auto-fit, minmax(110px,1fr));
    gap:20px;
    margin-top:8px;
  }

  .attr{
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border-radius:10px;
    padding:20px;
    display:flex;
    flex-direction:column;
    align-items:center;
    justify-content:center;
    gap:6px;
    cursor:pointer;
    transition: transform .16s ease, box-shadow .16s ease, border-color .16s ease;
    user-select:none;
  }
  .attr:hover {
    transform: translateY(-2px);
    box-shadow: 0 0 8px rgba(138, 43, 226, 0.4);
  }

  .attr .attr-label{ font-weight:700; color:#f4f6fb; white-space: nowrap;}
  .attr .attr-val{ font-weight:800; font-size:1.05rem; color:#eaeef8; }

  @keyframes clickPulse {
    0%{ transform: scale(1); box-shadow: 0 0 0 rgba(106,27,154,0.0); }
    40%{ transform: scale(1.06); box-shadow: 8px 24px rgba(106,27,154,0.22); }
    100%{ transform: scale(1); box-shadow: 0 0 0 rgba(106,27,154,0.0); }
  }
  .pulse { animation: clickPulse .5s ease forwards; }

  .attr.luck{
    border: 1px solid var(--gold);
    box-shadow: 0 6px 24px rgba(212,175,55,0.12), inset 0 1px 0 rgba(255,255,255,0.03);
  }
  .attr.luck.cooling{ border: 1px solid transparent; box-shadow:none; }

  .muted{ color: rgba(255,255,255,0.54); font-size:0.88rem; }
  .center{ text-align:center; }

  @media(max-width:420px){
    .bar-card{ padding:10px; }
    .btn{ padding:6px 8px; border-radius:7px; }
  }

  #resetBtn {
    position: fixed;
    top: 10px;
    left: 10px;
    background: #1f1f1f;
    color: white;
    border: none;
    border-radius: 6px;
    padding: 0.4rem 0.8rem;
    font-size: 0.9rem;
    font-weight: bold;
    cursor: pointer;
    z-index: 1000;
    transition: background 0.2s;
  }
  #resetBtn:hover { background: #ff4d4d; }

  /* Heart Button - Top Right */
  #heartBtn {
    position: fixed;
    top: 10px;
    right: 30px;
    width: 40px;
    height: 40px;
    background: transparent;
    border: 3px solid white;
    border-radius: 8px;
    cursor: pointer;
    z-index: 1001;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0;
  }
  #heartBtn svg {
    width: 24px;
    height: 24px;
    fill: transparent;
    stroke: white;
    stroke-width: 2;
    transition: all 0.3s ease;
  }
  #heartBtn.active {
    background: var(--scarlet-pink);
    border-color: #333;
  }
  #heartBtn.active svg {
    fill: var(--scarlet-pink);
    stroke: #333;
  }
  #heartBtn:hover:not(.disabled) {
    transform: scale(1.05);
  }
  #heartBtn.disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  /* Relationship Overlay */
  #relationshipOverlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(15, 15, 18, 0.85);
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    z-index: 999;
    display: none;
    overflow-y: auto;
    padding: 60px 16px 20px;
  }
  #relationshipOverlay.visible {
    display: block;
  }

  .relationship-content {
    max-width: 660px;
    margin: 0 auto;
  }

  .relationship-title {
    text-align: center;
    font-size: 1.8rem;
    font-weight: 700;
    margin-bottom: 24px;
    color: #fff;
  }

  /* NPC Card */
  .npc-card {
    background: rgba(255, 255, 255, 0.03);
    border-radius: 16px;
    padding: 8px;
    margin-bottom: 8px;
    display: flex;
    gap: 8px;
    align-items: stretch;
    position: relative;
  }

  /* NPC Image Placeholder - Simple & Clean */
  .npc-image {
      width: 150px;
      height: 150px;
      min-width: 150px;
      background: rgba(255, 255, 255, 0.05);
      border: 2px dashed rgba(255, 255, 255, 0.2);
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s ease;
      overflow: hidden;
  }

  .npc-image:hover {
    border-color: rgba(255, 255, 255, 0.4);
    background: rgba(255, 255, 255, 0.08);
  }
  
  .npc-image svg {
    width: 64px;
    height: 64px;
    stroke: rgba(255, 255, 255, 0.3);
    stroke-width: 2;
    fill: none;
  }
  
  .npc-image.has-image {
    border-style: solid;
    border-color: rgba(255, 255, 255, 0.1);
  }
  
  .npc-image img {
      width: 100%;
      height: 100%;
      object-fit: cover; /* Simple approach - fills container while preserving aspect ratio */
      border-radius: 10px;
      /* Limit maximum displayed size - prevent shrinking on narrow screens */
      max-width: 320px;
      max-height: 200px;
      min-width: 150px;
      min-height: 150px;
  }

  /* NPC Info */
  .npc-info {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 8px;
  }

  .npc-name-row {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .npc-name {
    font-size: 1.25rem;
    font-weight: 700;
    color: #fff;
    background: transparent;
    border: none;
    outline: none;
    padding: 4px 0;
    padding-left: 8px;
    flex: 1;
  }
  .npc-name::placeholder {
    color: rgba(255, 255, 255, 0.4);
  }

  .name-confirm-btn {
    position: absolute;
    top: 8px;
    right: 8px;
    width: 24px;
    height: 24px;
    min-width: 24px;
    background: rgba(76, 175, 80, 0.2);
    border: 1px solid rgba(76, 175, 80, 0.5);
    border-radius: 4px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.2s ease;
    opacity: 0;
    pointer-events: none;
  }
  .name-confirm-btn.visible {
    opacity: 1;
    pointer-events: auto;
  }
  .name-confirm-btn:hover {
    background: rgba(76, 175, 80, 0.4);
    border-color: rgba(76, 175, 80, 0.8);
  }
  .name-confirm-btn svg {
    width: 16px;
    height: 16px;
    stroke: #4caf50;
    stroke-width: 3;
    fill: none;
  }

  .npc-status {
    font-size: 1rem;
    color: var(--muted);
    background: transparent;
    border: none;
    outline: none;
    padding: 2px 0;
    padding-left: 8px;
    width: 100%;
  }
  .npc-status::placeholder {
    color: rgba(255, 255, 255, 0.3);
  }

  /* Hearts Container */
  .npc-hearts {
    display: flex;
    gap: 6px;
    margin-top: auto;
    padding-top: 4px;
    flex-wrap: wrap;
  }

  .heart-icon {
    width: 56px;
    height: 56px;
    position: relative;
    cursor: pointer;
    transition: all 0.2s ease;
  }
  .heart-icon:hover:not(.locked) {
    transform: scale(1.1);
  }
  .heart-icon.locked {
    opacity: 0.4;
    cursor: not-allowed;
  }
  .heart-icon svg {
    width: 100%;
    height: 100%;
    stroke-width: 2;
    transition: all 0.3s ease;
  }

  /* Heart states */
  .heart-icon.empty svg {
    fill: transparent;
    stroke: rgba(255, 255, 255, 0.3);
  }
  .heart-icon.filled-white svg {
    fill: var(--heart-white);
    stroke: var(--heart-white);
  }
  .heart-icon.filled-blue svg {
    fill: var(--heart-blue);
    stroke: var(--heart-blue);
  }
  .heart-icon.filled-purple svg {
    fill: var(--heart-purple);
    stroke: var(--heart-purple);
  }
  .heart-icon.filled-red svg {
    fill: var(--heart-red);
    stroke: var(--heart-red);
  }

  /* Heart number label inside heart */
  .heart-number {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 0.85rem;
    font-weight: 700;
    color: #333;
    pointer-events: none;
    user-select: none;
  }
  .heart-icon.empty .heart-number {
    color: rgba(255, 255, 255, 0.4);
  }

  /* Pulsing animation for heart 7 */
  @keyframes heartPulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.08); }
  }
  .heart-icon.pulse-heart {
    animation: heartPulse 2s ease-in-out infinite;
  }

  /* Add NPC Button */
  .add-npc-btn {
    width: 100%;
    padding: 16px;
    background: rgba(255, 255, 255, 0.03);
    border: 2px dashed rgba(255, 255, 255, 0.15);
    border-radius: 16px;
    color: rgba(255, 255, 255, 0.4);
    font-size: 1rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
  }
  .add-npc-btn:hover {
    background: rgba(255, 255, 255, 0.06);
    border-color: rgba(255, 255, 255, 0.3);
    color: rgba(255, 255, 255, 0.6);
  }
  .add-npc-btn svg {
    width: 20px;
    height: 20px;
    stroke: currentColor;
    stroke-width: 2;
    fill: none;
  }

  /* Delete NPC Button */
  .delete-npc-btn {
    position: absolute;
    bottom: 8px;
    right: 8px;
    width: 24px;
    height: 24px;
    background: rgba(255, 0, 0, 0.2);
    border: none;
    border-radius: 50%;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 0;
    transition: all 0.2s ease;
  }

  .npc-card:hover .delete-npc-btn {
    opacity: 1;
  }
  .delete-npc-btn:hover {
    background: rgba(255, 0, 0, 0.5);
  }
  .delete-npc-btn svg {
    width: 12px;
    height: 12px;
    stroke: white;
    stroke-width: 2;
    fill: none;
  }

  @media (max-width: 500px) {
    .npc-card {
      flex-direction: column;
      align-items: center;
    }
    /* Keep images at original size on mobile - no shrinking */
    .npc-image {
      width: 150px;
      height: 150px;
      min-width: 150px;
    }
    .npc-info {
      width: 100%;
      align-items: center;
      text-align: center;
    }
    .npc-name, .npc-status {
      text-align: center;
    }
    .npc-hearts {
      justify-content: center;
    }
  }

  @media (max-width: 640px) {
    .npc-card {
      flex-direction: row;
      align-items: stretch;
      max-width: 400px;
      padding: 4px;
    }
    /* Keep images at original size on mobile - no shrinking */
    .npc-image {
      min-width: 150px;
      width: 150px;
      height: 150px;
    }
    .npc-info {
      flex: 1;
      align-items: flex-start;
      padding-left: 8px;
    }
    .npc-name {
      font-size: 1rem;
      text-align: left;
    }
    .npc-status {
      font-size: 0.85rem;
      text-align: left;
    }
    .npc-hearts {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 2px;
      justify-content: flex-start;
      margin-top: 1px;
      padding-left: 0;
    }
    .heart-icon {
      width: 44px;
      height: 32px;
    }
    .heart-number {
      font-size: 0.7rem;
    }
    /* Fix alignment for hearts 5, 6, 7 to align left */
    .heart-icon:nth-child(5) {
      grid-column: 1;
    }
    .heart-icon:nth-child(6) {
      grid-column: 2;
    }
    .heart-icon:nth-child(7) {
      grid-column: 3;
    }
    /* Align both buttons properly on mobile */
    .name-confirm-btn {
      top: 6px;
      right: 6px;
    }
    .delete-npc-btn {
      bottom: 6px;
      right: 6px;
    }
  }


</style>
</head>
<body>
  <button id="resetBtn">RESET</button>
  
  <!-- Heart Button -->
  <button id="heartBtn" aria-label="Toggle Relationships">
    <svg viewBox="0 0 24 24">
      <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"/>
    </svg>
  </button>

  <!-- Relationship Overlay -->
  <div id="relationshipOverlay">
    <div class="relationship-content">
      <div class="relationship-title" id="relationshipTitle">Relationships</div>
      <div id="npcList"></div>
      <button class="add-npc-btn" id="addNpcBtn">
        <svg viewBox="0 0 24 24">
          <line x1="12" y1="5" x2="12" y2="19"/>
          <line x1="5" y1="12" x2="19" y2="12"/>
        </svg>
        Add Character
      </button>
    </div>
  </div>

  <div class="wrap">
    <input id="playerName" placeholder="PLAYER" aria-label="Player name" />

    <div class="bars" id="bars"></div>

    <div class="attributes" id="attributes"></div>
  </div>



<script>
/* ========= Persistence helpers ========= */
function saveState(key,value){ try{ localStorage.setItem(key, JSON.stringify(value)); }catch(e){} }
function loadState(key, fallback){ try{ const v = localStorage.getItem(key); return v ? JSON.parse(v) : fallback; }catch(e){ return fallback; } }

/* ========= Stat Bonus Tables ========= */
const enduranceBonuses = [
  null,
  { life: 2, stamina: 1, mana: 0, energy: 0 },
  { life: 2, stamina: 1, mana: 0, energy: 0 },
  { life: 2, stamina: 1, mana: 0, energy: 0 },
  { life: 2, stamina: 1, mana: 0, energy: 0 },
  { life: 2, stamina: 1, mana: 0, energy: 0 },
  { life: 2, stamina: 1, mana: 0, energy: 0 },
  { life: 1, stamina: 0, mana: 0, energy: 0 },
  { life: 1, stamina: 0, mana: 0, energy: 0 },
  { life: 1, stamina: 0, mana: 0, energy: 0 },
];

const skillBonuses = [
  null,
  { life: 1, stamina: 0, mana: 0, energy: 0 },
  { life: 1, stamina: 1, mana: 0, energy: 0 },
  { life: 1, stamina: 0, mana: 0, energy: 0 },
  { life: 1, stamina: 0, mana: 0, energy: 0 },
  { life: 1, stamina: 0, mana: 0, energy: 0 },
  { life: 1, stamina: 0, mana: 0, energy: 0 },
  { life: 0, stamina: 0, mana: 0, energy: 0 },
  { life: 0, stamina: 0, mana: 0, energy: 0 },
  { life: 0, stamina: 0, mana: 0, energy: 0 },
];

const strengthBonuses = [
  null,
  { life: 1, stamina: 0, mana: 0, energy: 0 },
  { life: 1, stamina: 0, mana: 0, energy: 0 },
  { life: 1, stamina: 0, mana: 0, energy: 0 },
  { life: 1, stamina: 0, mana: 0, energy: 0 },
  { life: 1, stamina: 1, mana: 0, energy: 0 },
  { life: 1, stamina: 0, mana: 0, energy: 0 },
  { life: 0, stamina: 0, mana: 0, energy: 0 },
  { life: 0, stamina: 0, mana: 0, energy: 0 },
  { life: 0, stamina: 0, mana: 0, energy: 0 },
];

const potencyBonuses = [
  null,
  { life: 0, stamina: 0, mana: 3, energy: 0 },
  { life: 0, stamina: 0, mana: 2, energy: 1 },
  { life: 0, stamina: 0, mana: 3, energy: 0 },
  { life: 0, stamina: 0, mana: 2, energy: 1 },
  { life: 0, stamina: 0, mana: 3, energy: 0 },
  { life: 0, stamina: 0, mana: 3, energy: 0 },
  { life: 0, stamina: 0, mana: 2, energy: 0 },
  { life: 0, stamina: 0, mana: 2, energy: 0 },
  { life: 0, stamina: 0, mana: 3, energy: 0 },
];

const masteryBonuses = [
  null,
  { life: 0, stamina: 0, mana: 1, energy: 2 },
  { life: 0, stamina: 0, mana: 0, energy: 3 },
  { life: 0, stamina: 0, mana: 1, energy: 3 },
  { life: 0, stamina: 0, mana: 0, energy: 3 },
  { life: 0, stamina: 0, mana: 0, energy: 2 },
  { life: 0, stamina: 0, mana: 0, energy: 2 },
  { life: 0, stamina: 0, mana: 0, energy: 2 },
  { life: 0, stamina: 0, mana: 0, energy: 2 },
  { life: 0, stamina: 0, mana: 0, energy: 2 },
];

/* ========= Calculate Maximum Limits ========= */
function calculateLimits() {
  const limits = {
    life: 3,
    stamina: 1,
    mana: 3,
    energy: 2
  };

  const endurance = Number(loadState('Endurance', 0)) || 0;
  const skill = Number(loadState('Skill', 0)) || 0;
  const strength = Number(loadState('Strength', 0)) || 0;
  const potency = Number(loadState('Potency', 0)) || 0;
  const mastery = Number(loadState('Mastery', 0)) || 0;

  function sumBonuses(bonusTable, rank) {
    let total = { life: 0, stamina: 0, mana: 0, energy: 0 };
    for (let i = 1; i <= rank && i < bonusTable.length; i++) {
      if (bonusTable[i]) {
        total.life += bonusTable[i].life;
        total.stamina += bonusTable[i].stamina;
        total.mana += bonusTable[i].mana;
        total.energy += bonusTable[i].energy;
      }
    }
    return total;
  }

  const endBonus = sumBonuses(enduranceBonuses, endurance);
  const skillBonus = sumBonuses(skillBonuses, skill);
  const strBonus = sumBonuses(strengthBonuses, strength);
  const potBonus = sumBonuses(potencyBonuses, potency);
  const mastBonus = sumBonuses(masteryBonuses, mastery);

  limits.life += endBonus.life + skillBonus.life + strBonus.life + potBonus.life + mastBonus.life;
  limits.stamina += endBonus.stamina + skillBonus.stamina + strBonus.stamina + potBonus.stamina + mastBonus.stamina;
  limits.mana += endBonus.mana + skillBonus.mana + strBonus.mana + potBonus.mana + mastBonus.mana;
  limits.energy += endBonus.energy + skillBonus.energy + strBonus.energy + potBonus.energy + mastBonus.energy;

  return limits;
}

/* ========= Bar Update Registry ========= */
const barUpdateFunctions = {};

/* ========= Bars config with min/max ranges and defaults ========= */
const barsConfig = [
  { key:'life', label:'Life', dotClass:'dot-life', min: -10, max: 30, default: 3, dynamic: true },
  { key:'mana', label:'Mana', dotClass:'dot-mana', min: -1, max: 30, default: 0, dynamic: true },
  { key:'stamina', label:'Stamina', dotClass:'dot-stamina', min: -3, max: 9, default: 1, dynamic: true },
  { key:'energy', label:'Energy', dotClass:'dot-energy', min: -1, max: 30, default: 0, dynamic: true },
  { key:'empower', label:'Empower', dotClass:'dot-empower', min: 0, max: 12, default: 0, dynamic: false },
  { key:'coalesce', label:'Coalesce', dotClass:'dot-coalesce', min: 0, max: 12, default: 3, dynamic: false }
];

const barsContainer = document.getElementById('bars');

barsConfig.forEach(cfg => {
  let value = Number(loadState(cfg.key, cfg.default));
  value = Math.max(cfg.min, Math.min(cfg.max, value));
  
  const card = document.createElement('div');
  card.className = 'bar-card';
  card.dataset.key = cfg.key;

  const left = document.createElement('div'); left.className='bar-left';
  const dot = document.createElement('div'); dot.className = 'bar-dot ' + cfg.dotClass;
  const label = document.createElement('div'); label.className='bar-label'; label.textContent = cfg.label;

  left.appendChild(dot);
  left.appendChild(label);

  const controls = document.createElement('div'); controls.className='bar-controls';

  const minus = document.createElement('button'); minus.className='btn'; minus.textContent='−';
  const valSpan = document.createElement('div'); valSpan.className='bar-value';
  const plus = document.createElement('button'); plus.className='btn'; plus.textContent='+';

  function getCurrentMax() {
    if (cfg.dynamic) {
      const limits = calculateLimits();
      return limits[cfg.key];
    }
    return cfg.max;
  }

  function updateDisplay() {
    if (cfg.dynamic) {
      const currentMax = getCurrentMax();
      valSpan.textContent = `${value} / ${currentMax}`;
    } else {
      valSpan.textContent = String(value);
    }
  }

  function updateButtonStates() {
    const currentMax = getCurrentMax();
    minus.disabled = (value <= cfg.min);
    plus.disabled = (value >= currentMax);
  }

  function updateBar() {
    const currentMax = getCurrentMax();
    if (value > currentMax) {
      value = currentMax;
      saveState(cfg.key, value);
    }
    updateDisplay();
    updateButtonStates();
  }

  if (cfg.dynamic) {
    barUpdateFunctions[cfg.key] = updateBar;
  }

  minus.addEventListener('click', ()=> {
    const newValue = value - 1;
    if (newValue >= cfg.min) {
      value = newValue;
      updateDisplay();
      saveState(cfg.key, value);
      updateButtonStates();
      flashElement(card);
    }
  });
  
  plus.addEventListener('click', ()=> {
    const currentMax = getCurrentMax();
    const newValue = value + 1;
    if (newValue <= currentMax) {
      value = newValue;
      updateDisplay();
      saveState(cfg.key, value);
      updateButtonStates();
      flashElement(card);
    }
  });

  updateDisplay();
  updateButtonStates();

  controls.appendChild(minus);
  controls.appendChild(valSpan);
  controls.appendChild(plus);

  card.appendChild(left);
  card.appendChild(controls);

  barsContainer.appendChild(card);
});

function updateAllBars() {
  Object.values(barUpdateFunctions).forEach(updateFn => updateFn());
}

function flashElement(el){
  el.style.transition = 'box-shadow .18s ease, transform .12s ease';
  el.style.transform = 'translateY(-2px)';
  el.style.boxShadow = '0 14px 36px rgba(0,0,0,0.55)';
  setTimeout(()=>{ el.style.transform=''; el.style.boxShadow=''; }, 160);
}

/* ========= Attributes (including Luck) ========= */
const attrConfig = ["Endurance","Skill","Strength","Potency","Mastery","Luck"];
const attrsContainer = document.getElementById('attributes');

const limitAffectingAttrs = ["Endurance", "Skill", "Strength", "Potency", "Mastery"];

attrConfig.forEach(name => {
  let stored = loadState(name, name==='Luck' ? null : 0);
  if(name!=='Luck') stored = Number(stored) || 0;

  const card = document.createElement('div');
  card.className = 'attr';
  card.dataset.name = name;

  const label = document.createElement('div'); label.className='attr-label'; label.textContent = name;
  const val = document.createElement('div'); val.className='attr-val'; val.textContent = (name==='Luck' ? '--' : stored);

  card.appendChild(label);
  card.appendChild(val);
  attrsContainer.appendChild(card);

  if(name === 'Luck'){
    card.classList.add('luck');
    let luckValue = loadState('Luck', null);
    let showing = Boolean(loadState('luckShowing', false));
    let lastLuck = loadState('luckLast', null);
    let cooldownUntil = loadState('luckCooldownUntil', null);
    let timerId = null;

    function formatLuck(n){ return (n>=0? '+'+n : String(n)); }

    function getRemainingSec(){
      if(!cooldownUntil) return 0;
      const rem = Math.ceil((cooldownUntil - Date.now())/1000);
      return rem>0? rem: 0;
    }

    function updateLuckDisplay(){
      const rem = getRemainingSec();
      if(showing && rem>0){
        label.textContent = `Luck (${rem}s)`;
        val.textContent = formatLuck(luckValue);
        card.classList.add('cooling');
      } else if(showing){
        label.textContent = 'Luck';
        val.textContent = formatLuck(luckValue);
        card.classList.remove('cooling');
      } else {
        label.textContent = 'Luck';
        val.textContent = '--';
        card.classList.remove('cooling');
      }
    }

    function startCooldown(seconds){
      const until = Date.now() + seconds*1000;
      cooldownUntil = until;
      saveState('luckCooldownUntil', until);
      updateLuckDisplay();
      if(timerId) clearInterval(timerId);
      timerId = setInterval(()=>{
        const rem = getRemainingSec();
        if(rem<=0){
          clearInterval(timerId); timerId = null;
          cooldownUntil = null; saveState('luckCooldownUntil', null);
          updateLuckDisplay();
        } else {
          updateLuckDisplay();
        }
      }, 1000);
    }

    function rollLuckWeighted(){
      const options = [
        {value:-1, weight:10},
        {value:0, weight:10},
        {value:1, weight:23},
        {value:2, weight:23},
        {value:3, weight:23},
        {value:4, weight:10},
        {value:10, weight:1}
      ];
      const total = options.reduce((s,o)=>s+o.weight,0);
      let r = Math.random()*total;
      for(let i=0;i<options.length;i++){
        if(r < options[i].weight) return options[i].value;
        r -= options[i].weight;
      }
      return options[options.length-1].value;
    }

    function pickNewLuck(){
      let newVal;
      let attempts = 0;
      do {
        newVal = rollLuckWeighted();
        attempts++;
        if(attempts>10) break;
      } while(newVal === lastLuck);
      lastLuck = newVal;
      saveState('luckLast', lastLuck);
      return newVal;
    }

    if(showing){
      luckValue = loadState('Luck', luckValue);
    } else {
      luckValue = loadState('Luck', null);
    }
    updateLuckDisplay();

    card.addEventListener('click', ()=>{
      const rem = getRemainingSec();
      if(rem > 0) {
        return;
      }
      if(!showing){
        luckValue = pickNewLuck();
        showing = true;
        saveState('Luck', luckValue);
        saveState('luckShowing', true);
        startCooldown(60);
        card.classList.add('pulse');
        setTimeout(()=> card.classList.remove('pulse'), 520);
      } else {
        showing = false;
        luckValue = null;
        saveState('Luck', null);
        saveState('luckShowing', false);
        updateLuckDisplay();
        card.classList.add('pulse');
        setTimeout(()=> card.classList.remove('pulse'), 320);
      }
    });

    if(cooldownUntil){
      const rem = getRemainingSec();
      if(rem>0){
        showing = true;
        saveState('luckShowing', true);
        updateLuckDisplay();
        if(timerId) clearInterval(timerId);
        timerId = setInterval(()=>{
          const r = getRemainingSec();
          if(r<=0){
            clearInterval(timerId); timerId=null;
            cooldownUntil = null;
            saveState('luckCooldownUntil', null);
            updateLuckDisplay();
          } else updateLuckDisplay();
        },1000);
      } else {
        cooldownUntil = null;
        saveState('luckCooldownUntil', null);
        updateLuckDisplay();
      }
    }

  } else {
    let valNum = stored;
    let lockout = false;

    card.addEventListener('click', ()=>{
      if(lockout) return;
      valNum = (valNum + 1) % 10;
      val.textContent = String(valNum);
      saveState(name, valNum);

      if (limitAffectingAttrs.includes(name)) {
        updateAllBars();
      }

      card.classList.add('pulse');
      setTimeout(()=> card.classList.remove('pulse'), 420);

      lockout = true;
      setTimeout(()=> { lockout = false; }, 3000);
    });
  }
});

/* ========= Player name persistence and Enter handling ========= */
const playerNameInput = document.getElementById('playerName');
const existingName = loadState('playerName', '');
if(existingName) playerNameInput.value = existingName;
playerNameInput.addEventListener('keydown', (e)=>{
  if(e.key === 'Enter'){
    const nm = playerNameInput.value.trim();
    saveState('playerName', nm);
    playerNameInput.blur();
  }
});
playerNameInput.addEventListener('blur', ()=>{
  const nm = playerNameInput.value.trim();
  saveState('playerName', nm);
});

/* Reset button */
document.getElementById("resetBtn").onclick = () => {
  if (confirm("Are you sure you want to RESET ALL DATA?")) {
    localStorage.clear();
    location.reload();
  }
};

/* ========= Relationship System ========= */
const heartBtn = document.getElementById('heartBtn');
const relationshipOverlay = document.getElementById('relationshipOverlay');
const npcList = document.getElementById('npcList');
const addNpcBtn = document.getElementById('addNpcBtn');
const relationshipTitle = document.getElementById('relationshipTitle');

// Update relationship title with player name
function updateRelationshipTitle() {
  const name = playerNameInput.value.trim() || 'Player';
  relationshipTitle.textContent = `${name}'s Relationships`;
}

updateRelationshipTitle();

// Toggle relationship overlay
let isRelationshipOpen = false;

// Check if player has a name
function hasPlayerName() {
  return playerNameInput.value.trim().length > 0;
}

// Update heart button state
function updateHeartButtonState() {
  if (hasPlayerName()) {
    heartBtn.classList.remove('disabled');
  } else {
    heartBtn.classList.add('disabled');
  }
}

heartBtn.addEventListener('click', () => {
  if (!hasPlayerName()) {
    alert('Please enter a player name first!');
    return;
  }
  
  isRelationshipOpen = !isRelationshipOpen;
  if (isRelationshipOpen) {
    relationshipOverlay.classList.add('visible');
    heartBtn.classList.add('active');
    updateRelationshipTitle();
  } else {
    relationshipOverlay.classList.remove('visible');
    heartBtn.classList.remove('active');
  }
});

// Update button state on player name change
playerNameInput.addEventListener('input', () => {
  updateHeartButtonState();
  updateRelationshipTitle();
});
updateHeartButtonState();

// Heart SVG path
const heartPath = 'M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z';

// NPC data management
let npcs = loadState('npcs', []);

function saveNpcs() {
  saveState('npcs', npcs);
}

// Calculate relationship status based on filled hearts
function getRelationshipStatus(hearts, npcName) {
  let filledCount = 0;
  for (let i = 0; i < hearts.length; i++) {
    if (hearts[i] === 1) {
      filledCount++;
    } else {
      break;  // Stop at first unfilled heart?
    }
  }

  // Special case: Naya's rank 7 is "Best Friend"
  if (npcName === "Naya" && filledCount === 7) {
    return "Best Friend";
  }

  const statusMap = {
    0: 'No Relationship',
    1: 'Familiar',
    2: 'Friendly',
    3: 'Friends',
    4: 'Accomplice',
    5: 'Companion',
    6: 'Partner',
    7: 'Lover'
  };
  
  return statusMap[filledCount] || 'No Relationship';
}


// Update NPC status when hearts change
function updateNpcStatus(npcIndex) {
  if (npcs[npcIndex]) {
    npcs[npcIndex].status = getRelationshipStatus(
    npcs[npcIndex].hearts,
    npcs[npcIndex].name
    );

  }
}

/* === NPC NAME → AUTO IMAGE TABLE === */

const officialNpcImages = {
  "Hitomi":           "hearts/000.webp",
  "Tsubasa":          "hearts/001.webp",
  "Tress Bien":       "hearts/002.webp",
  "Dante Alimor":     "hearts/003.webp",
  "Evelynn":          "hearts/004.webp",
  "Flare vey Byornn": "hearts/005.webp",
  "Guy":              "hearts/006.webp",
  "Hector Havel":     "hearts/007.webp",
  "Jiu-lin Fan":      "hearts/008.webp",
  "Shang Tian":       "hearts/009.webp",
  "Marco":            "hearts/010.webp",
  "Lumiere":          "hearts/011.webp",
  "Anjali":           "hearts/012.webp",
  "Chinara Ekine":    "hearts/013.webp",
  "Ohm":              "hearts/014.webp",
  "Jon Quixote":      "hearts/015.webp",
  "Naya":             "hearts/016.webp",
  "Million Redgate":  "hearts/017.webp",
  "Captain Thiffany": "hearts/018.webp",
  "The Courier":      "hearts/019.webp",
  "Paarthi Lomedi":   "hearts/035.webp",
  "Qing Xi":          "hearts/036.webp",
  "Reeve S Basilisk": "hearts/037.webp",
  "Vincent Pererez":  "hearts/038.webp",
  "Taeonora 9C":      "hearts/039.webp"
}

function createNpcCard(npc, index) {
  const card = document.createElement('div');
  card.className = 'npc-card';
  card.dataset.index = index;

  // Delete button
  const deleteBtn = document.createElement('button');
  deleteBtn.className = 'delete-npc-btn';
  deleteBtn.innerHTML = '<svg viewBox="0 0 24 24"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>';
  deleteBtn.addEventListener('click', () => {
    if (confirm('Delete this character?')) {
      // Remove "official" lock when NPC is deleted
      if (npcs[index]) {
        npcs[index].official = false;
      }
      npcs.splice(index, 1);

      saveNpcs();
      renderNpcs();
      updateAddButtonVisibility();
    }
  });

  // Image placeholder
  const imageDiv = document.createElement('div');
  imageDiv.className = 'npc-image' + (npc.image ? ' has-image' : '');
  
  if (npc.image) {
    const img = document.createElement('img');
    img.src = npc.image;
    imageDiv.appendChild(img);
  } else {
    imageDiv.innerHTML = '<svg viewBox="0 0 24 24"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>';
  }

  // Image upload - Direct upload (no cropping)
  const fileInput = document.createElement('input');
  fileInput.type = 'file';
  fileInput.accept = 'image/*';
  fileInput.style.display = 'none';
  
  fileInput.addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (file) {
      // Validate file type
      if (!file.type.startsWith('image/')) {
        alert('Please select an image file.');
        return;
      }
      
      // Validate file size (5MB limit)
      if (file.size > 5 * 1024 * 1024) {
        alert('Image file size must be less than 5MB.');
        return;
      }
      
      // Read and display image
      const reader = new FileReader();
      reader.onload = function(event) {
        npcs[index].image = event.target.result;
        saveNpcs();
        renderNpcs();
      };
      reader.readAsDataURL(file);
    }
  });

  imageDiv.addEventListener('click', () => {
    if (npcs[index].official) {
      alert("This is an official character. Their portrait cannot be changed.");
      return;
    }
    if (!npcs[index].name || npcs[index].name.trim().length === 0) {
      alert("Please enter a name before selecting an image.");
      return;
    }
    fileInput.click();
  });

  // Info section
  const infoDiv = document.createElement('div');
  infoDiv.className = 'npc-info';

  const nameInput = document.createElement('input');
  nameInput.className = 'npc-name';
  nameInput.placeholder = 'Character Name';
  nameInput.value = npc.name || '';
  // Create name row container with input and checkmark
  const nameRow = document.createElement('div');
  nameRow.className = 'npc-name-row';

  // Create checkmark button
  const confirmBtn = document.createElement('button');
  confirmBtn.className = 'name-confirm-btn';
  confirmBtn.innerHTML = '<svg viewBox="0 0 24 24"><polyline points="20 6 9 17 4 12"/></svg>';
  confirmBtn.title = 'Save name';

  // Function to save the name and update hearts
  function saveName() {
    const oldName = npcs[index].name || '';
    const newName = nameInput.value.trim();

    // Update local NPC name
    npcs[index].name = newName;

    // Handle hearts auto-fill / wipe
    if (oldName.length === 0 && newName.length > 0) {
      npcs[index].hearts[0] = 1;
    } else if (newName.length === 0) {
      npcs[index].hearts = [0,0,0,0,0,0,0];
      npcs[index].image = null;
    }

    /* === AUTO-SELECT IMAGE IF NAME IS OFFICIAL === */
    if (officialNpcImages[newName]) {
      npcs[index].image = officialNpcImages[newName];
      npcs[index].official = true;   // lock image editing
    } else {
      if (!npcs[index].official) {
        // Only clear image if NPC was not official
        // (prevents losing portraits accidentally)
        // Leave existing custom image unchanged
      }
      npcs[index].official = false;
    }

    updateNpcStatus(index);
    saveNpcs();
    renderNpcs();
  }


  // Show checkmark when typing
  nameInput.addEventListener('input', () => {
    const currentValue = nameInput.value.trim();
    const savedName = npcs[index].name || '';
    
    if (currentValue !== savedName && currentValue.length > 0) {
      confirmBtn.classList.add('visible');
    } else {
      confirmBtn.classList.remove('visible');
    }
  });

  // Save on Enter key
  nameInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      saveName();
      nameInput.blur();
    }
  });

  // Save on checkmark click
  confirmBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    saveName();
  });

  nameRow.appendChild(nameInput);
  nameRow.appendChild(confirmBtn);

  const statusInput = document.createElement('div');
  statusInput.className = 'npc-status';
  statusInput.textContent = npc.status || 'No Relationship';

  // Hearts
  const heartsDiv = document.createElement('div');
  heartsDiv.className = 'npc-hearts';

  // Initialize hearts array if needed (7 hearts)
  if (!npc.hearts || npc.hearts.length !== 7) {
    npc.hearts = [0, 0, 0, 0, 0, 0, 0];
  }

  // Auto-fill first heart if NPC has a name
  const hasName = npc.name && npc.name.trim().length > 0;
  if (hasName && npc.hearts[0] === 0) {
    npc.hearts[0] = 1;
    updateNpcStatus(index);
    saveNpcs();
  }

  // Initialize status if not set
  if (!npc.status) {
    updateNpcStatus(index);
    saveNpcs();
  }

  // Create 7 hearts
  for (let i = 0; i < 7; i++) {
    const heartIcon = document.createElement('div');
    heartIcon.className = 'heart-icon';
    heartIcon.dataset.heartIndex = i;
    
    const heartLevel = npc.hearts[i];
    
    // Determine heart color based on index
    // Heart 0: white, Hearts 1-2: blue, Hearts 3-4: purple, Hearts 5-6: red
    if (heartLevel === 0) {
      heartIcon.classList.add('empty');
    } else {
      if (i === 0) {
        heartIcon.classList.add('filled-white');
      } else if (i >= 1 && i <= 2) {
        heartIcon.classList.add('filled-blue');
      } else if (i >= 3 && i <= 4) {
        heartIcon.classList.add('filled-purple');
      } else if (i >= 5 && i <= 6) {
        heartIcon.classList.add('filled-red');
      }
    }

    // Add pulse animation to heart 7 when filled
    if (i === 6 && heartLevel === 1) {
      heartIcon.classList.add('pulse-heart');
    }

    // Check if heart is locked (previous heart not filled)
    const isLocked = !hasName || (i > 0 && npc.hearts[i - 1] === 0);
    if (isLocked) {
      heartIcon.classList.add('locked');
    }

    heartIcon.innerHTML = `<svg viewBox="0 0 24 24"><path d="${heartPath}"/></svg><div class="heart-number">${i + 1}</div>`;

    heartIcon.addEventListener('click', () => {
      // Cannot click if no name
      if (!hasName) {
        alert('Please enter a character name first!');
        return;
      }

      // Heart 1 (index 0) is auto-filled, cannot be toggled
      if (i === 0) {
        return;
      }

      // Check if previous heart is filled
      if (i > 0 && npc.hearts[i - 1] === 0) {
        return; // Locked
      }

      // Toggle heart
      npcs[index].hearts[i] = npcs[index].hearts[i] === 0 ? 1 : 0;
      
      // If unfilling a heart, unfill all hearts after it
      if (npcs[index].hearts[i] === 0) {
        for (let j = i + 1; j < 7; j++) {
          npcs[index].hearts[j] = 0;
        }
      }
      
      // Update the relationship status
      updateNpcStatus(index);
      
      saveNpcs();
      renderNpcs();
    });

    heartsDiv.appendChild(heartIcon);
  }

  infoDiv.appendChild(nameRow);
  infoDiv.appendChild(statusInput);
  infoDiv.appendChild(heartsDiv);

  card.appendChild(deleteBtn);
  card.appendChild(imageDiv);
  // Add file input to card
  card.appendChild(fileInput);
  card.appendChild(infoDiv);

  return card;
}

function renderNpcs() {
  npcList.innerHTML = '';
  npcs.forEach((npc, index) => {
    npcList.appendChild(createNpcCard(npc, index));
  });
  updateAddButtonVisibility();
}

// Add new NPC
addNpcBtn.addEventListener('click', () => {
  if (npcs.length >= 3) {
    alert('Maximum of 3 characters allowed');
    return;
  }
  npcs.push({
    name: '',
    status: 'No Relationship',
    image: null,
    hearts: [0, 0, 0, 0, 0, 0, 0]
  });
  saveNpcs();
  renderNpcs();
  updateAddButtonVisibility();
});

// Update add button visibility
function updateAddButtonVisibility() {
  if (npcs.length >= 3) {
    addNpcBtn.style.display = 'none';
  } else {
    addNpcBtn.style.display = 'flex';
  }
}

// Initial render
renderNpcs();
updateAddButtonVisibility();

/*I need to figure out how to do 'profile pic' style image cropping so users can align their NPCs. 
Also: maybe players must name their character first, then they can upload an image: if the name Matches one of the in-universe NPCs, it will autofill an image of their card or face art; otherwise the user can use the image-picker.
Note: NAYA and The Courier only have 6 hearts.
There are 5 FOEs that are also romance-able but their romance names are different from their FOE name.
*/



</script>
</body>
</html>