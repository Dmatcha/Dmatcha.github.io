<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Player Tracker — Player</title>
<style>
  :root{
    --bg:#121212;
    --card:#1f1f1f;
    --muted:#9aa3ad;
    --accent-purple: rgba(106,27,154,0.22);
    --gold: #D4AF37;
    --blue-cool:#66ccff;
    --glass: rgba(255,255,255,0.04);
  }

  html,body{height:100%;margin:0;}
  body{
    margin:0;
    min-height:100%;
    font-family: "Inter", "Segoe UI", Arial, sans-serif;
    background: linear-gradient(180deg,#0f0f12 0%, #141417 60%);
    color:#e9eef6;
    -webkit-font-smoothing:antialiased;
    -moz-osx-font-smoothing:grayscale;
  }

  .wrap{
    max-width:900px;
    margin:16px auto;
    padding:18px;
  }

  /* Player name */
  #playerName{
    width:100%;
    display:block;
    font-size:2.0rem;
    text-align:center;
    background:transparent;
    color: #fff;
    border: 0;
    outline:0;
    padding:8px 4px;
    margin-bottom:14px;
  }
  #playerName::placeholder{ color: rgba(255,255,255,0.25); }

  /* ---------- Bars layout: grid 2 cols on wide, 1 col + reorder on small ---------- */
  .bars {
    display:grid;
    grid-template-columns: repeat(2, minmax(220px, 1fr));
    gap:20px;
    margin-bottom:16px;
  }

  /* NOTE: we do NOT change DOM order. On wide screens the default grid
     places items row-major (left→right, top→bottom) which gives:
       Life   Mana
       Stamina Energy
       Empower Coalesce
     On narrow screens we switch to 1 column and use `order` to reorder items
     into the sequence you requested (column-major style).
  */

  @media (max-width: 720px) {
    .bars { grid-template-columns: 1fr; } /* single column on small screens */

    /* mobile stacking order (explicit) */
    .bar-card[data-key="life"]     { order: 1; }
    .bar-card[data-key="stamina"]  { order: 2; }
    .bar-card[data-key="empower"]  { order: 3; }
    .bar-card[data-key="mana"]     { order: 4; }
    .bar-card[data-key="energy"]   { order: 5; }
    .bar-card[data-key="coalesce"] { order: 6; }
  }

  /* Ensure no ordering surprises on wide screens: reset order to initial */
  @media (min-width: 721px) {
    .bar-card { order: initial; }
  }

  .bar-card{
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border-radius:20px;
    padding:16px 18px;
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:20px;
    box-shadow: 0 6px 18px rgba(0,0,0,0.6);
    transition: transform .14s ease, box-shadow .14s ease;
  }
  .bar-card:hover{ transform: translateY(-2px); box-shadow: 0 20px 30px rgba(0,0,0,0.7); }

  .bar-left{
    display:flex;
    align-items:center;
    gap:14px;
    min-width: 0;
  }

  /* color dot (scaled) */
  .bar-dot{
    width: clamp(22px, 2.5vw, 34px);
    height: clamp(22px, 2.5vw, 34px);
    border-radius:50%;
    box-shadow: 0 2px 6px rgba(0,0,0,0.6), inset 0 -1px 0 rgba(255,255,255,0.05);
    flex: 0 0 auto;
  }
  .dot-life{ background: linear-gradient(180deg,#5fd08f,#2fb96b); }
  .dot-stamina{ background: linear-gradient(180deg,#6fb8ff,#2b74ff); }
  .dot-mana{ background: linear-gradient(180deg,#ffc46b,#ff9a2b); }
  .dot-energy{ background: linear-gradient(180deg,#6ff0ff,#13b6ff); }
  .dot-empower{ background: linear-gradient(180deg,#ff4d4d,#DC143C); }
  .dot-coalesce{ background: linear-gradient(180deg,#f5f7fa,#d9dde6); border:1px solid rgba(255,255,255,0.06); }

  .bar-label{ font-weight:600; font-size:1.38rem; color:#f1f5fb; white-space:nowrap; }
  .bar-controls{ display:flex; align-items:center; gap:8px; }

  .bar-value{
    min-width:50px;
    text-align:center;
    font-weight:700;
    font-size:1.10rem;
    color:#ffffff;
  }

  .btn {
    -webkit-appearance:none;
    appearance:none;
    border:0;
    background: rgba(255,255,255,0.06);
    color: #fff;
    padding:6px 10px;
    border-radius:8px;
    cursor:pointer;
    font-weight:700;
    transition: transform .12s ease, background .12s ease, box-shadow .12s ease;
  }
  .btn:active{ transform: scale(.97); }
  .btn:focus{ outline:none; box-shadow:0 0 0 3px rgba(102,204,255,0.12); }

  /* Attributes grid */
  .attributes{
    display:grid;
    grid-template-columns: repeat(auto-fit, minmax(110px,1fr));
    gap:20px;
    margin-top:8px;
  }

  .attr{
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border-radius:10px;
    padding:20px;
    display:flex;
    flex-direction:column;
    align-items:center;
    justify-content:center;
    gap:6px;
    cursor:pointer;
    transition: transform .16s ease, box-shadow .16s ease, border-color .16s ease;
    user-select:none;
  }
  .attr:hover {
    transform: translateY(-2px);
    box-shadow: 0 0 8px rgba(138, 43, 226, 0.4);
  }

  .attr .attr-label{ font-weight:700; color:#f4f6fb; white-space: nowrap;}
  .attr .attr-val{ font-weight:800; font-size:1.05rem; color:#eaeef8; }

  /* click pulse */
  @keyframes clickPulse {
    0%{ transform: scale(1); box-shadow: 0 0 0 rgba(106,27,154,0.0); }
    40%{ transform: scale(1.06); box-shadow: 0 8px 24px rgba(106,27,154,0.22); }
    100%{ transform: scale(1); box-shadow: 0 0 0 rgba(106,27,154,0.0); }
  }
  .pulse { animation: clickPulse .5s ease forwards; }

  /* Luck special */
  .attr.luck{
    border: 1px solid var(--gold);
    box-shadow: 0 6px 24px rgba(212,175,55,0.12), inset 0 1px 0 rgba(255,255,255,0.03);
  }
  .attr.luck.cooling{ border: 1px solid transparent; box-shadow:none; }

  /* small helpers */
  .muted{ color: rgba(255,255,255,0.54); font-size:0.88rem; }
  .center{ text-align:center; }

  @media(max-width:420px){
    .bar-card{ padding:10px; }
    .btn{ padding:6px 8px; border-radius:7px; }
  }

  #resetBtn {
    position: fixed;
    top: 10px;
    left: 10px;
    background: #1f1f1f;
    color: white;
    border: none;
    border-radius: 6px;
    padding: 0.4rem 0.8rem;
    font-size: 0.9rem;
    font-weight: bold;
    cursor: pointer;
    z-index: 1000;
    transition: background 0.2s;
  }
  #resetBtn:hover { background: #ff4d4d; }
</style>
</head>
<body>
  <button id="resetBtn">RESET</button>
  <div class="wrap">
    <input id="playerName" placeholder="PLAYER" aria-label="Player name" />

    <div class="bars" id="bars"></div>

    <div class="attributes" id="attributes"></div>
  </div>

<script>
/* ========= Persistence helpers ========= */
function saveState(key,value){ try{ localStorage.setItem(key, JSON.stringify(value)); }catch(e){} }
function loadState(key, fallback){ try{ const v = localStorage.getItem(key); return v ? JSON.parse(v) : fallback; }catch(e){ return fallback; } }

/* ========= Bars config (DOM order produces two-column row-major layout) ========= */
const barsConfig = [
  { key:'life', label:'Life', dotClass:'dot-life' },
  { key:'mana', label:'Mana', dotClass:'dot-mana' },
  { key:'stamina', label:'Stamina', dotClass:'dot-stamina' },
  { key:'energy', label:'Energy', dotClass:'dot-energy' },
  { key:'empower', label:'Empower', dotClass:'dot-empower' },
  { key:'coalesce', label:'Coalesce', dotClass:'dot-coalesce' }
];

const barsContainer = document.getElementById('bars');

/* build bar cards (no icons) */
barsConfig.forEach(cfg => {
  let value = Number(loadState(cfg.key, 0)); // start at saved or 0
  const card = document.createElement('div');
  card.className = 'bar-card';
  card.dataset.key = cfg.key;

  const left = document.createElement('div'); left.className='bar-left';
  const dot = document.createElement('div'); dot.className = 'bar-dot ' + cfg.dotClass;
  const label = document.createElement('div'); label.className='bar-label'; label.textContent = cfg.label;

  left.appendChild(dot);
  left.appendChild(label);

  const controls = document.createElement('div'); controls.className='bar-controls';

  const minus = document.createElement('button'); minus.className='btn'; minus.textContent='−';
  const valSpan = document.createElement('div'); valSpan.className='bar-value'; valSpan.textContent = String(value);
  const plus = document.createElement('button'); plus.className='btn'; plus.textContent='+';

  /* handlers */
  minus.addEventListener('click', ()=> {
    value = value - 1;
    valSpan.textContent = String(value);
    saveState(cfg.key, value);
    flashElement(card);
  });
  plus.addEventListener('click', ()=> {
    value = value + 1;
    valSpan.textContent = String(value);
    saveState(cfg.key, value);
    flashElement(card);
  });

  controls.appendChild(minus);
  controls.appendChild(valSpan);
  controls.appendChild(plus);

  card.appendChild(left);
  card.appendChild(controls);

  barsContainer.appendChild(card);
});

/* small flash animation by temporarily lifting/shading (no layout shift) */
function flashElement(el){
  el.style.transition = 'box-shadow .18s ease, transform .12s ease';
  el.style.transform = 'translateY(-4px)';
  el.style.boxShadow = '0 14px 36px rgba(0,0,0,0.55)';
  setTimeout(()=>{ el.style.transform=''; el.style.boxShadow=''; }, 160);
}

/* ========= Attributes (including Luck) ========= */
const attrConfig = ["Endurance","Skill","Strength","Potency","Mastery","Luck"];
const attrsContainer = document.getElementById('attributes');

attrConfig.forEach(name => {
  let stored = loadState(name, name==='Luck' ? null : 0);
  if(name!=='Luck') stored = Number(stored) || 0;

  const card = document.createElement('div');
  card.className = 'attr';
  card.dataset.name = name;

  const label = document.createElement('div'); label.className='attr-label'; label.textContent = name;
  const val = document.createElement('div'); val.className='attr-val'; val.textContent = (name==='Luck' ? '--' : stored);

  card.appendChild(label);
  card.appendChild(val);
  attrsContainer.appendChild(card);

  if(name === 'Luck'){
    card.classList.add('luck');
    // Luck state variables
    let luckValue = loadState('Luck', null); // persisted value or null
    let showing = Boolean(loadState('luckShowing', false));
    let lastLuck = loadState('luckLast', null);
    let cooldownUntil = loadState('luckCooldownUntil', null); // ms timestamp (nullable)
    let timerId = null;

    function formatLuck(n){ return (n>=0? '+'+n : String(n)); }

    function getRemainingSec(){
      if(!cooldownUntil) return 0;
      const rem = Math.ceil((cooldownUntil - Date.now())/1000);
      return rem>0? rem: 0;
    }

    function updateLuckDisplay(){
      const rem = getRemainingSec();
      if(showing && rem>0){
        label.textContent = `Luck (${rem}s)`;
        val.textContent = formatLuck(luckValue);
        card.classList.add('cooling');
      } else if(showing){
        label.textContent = 'Luck';
        val.textContent = formatLuck(luckValue);
        card.classList.remove('cooling');
      } else {
        label.textContent = 'Luck';
        val.textContent = '--';
        card.classList.remove('cooling');
      }
    }

    function startCooldown(seconds){
      const until = Date.now() + seconds*1000;
      cooldownUntil = until;
      saveState('luckCooldownUntil', until);
      updateLuckDisplay();
      if(timerId) clearInterval(timerId);
      timerId = setInterval(()=>{
        const rem = getRemainingSec();
        if(rem<=0){
          clearInterval(timerId); timerId = null;
          cooldownUntil = null; saveState('luckCooldownUntil', null);
          updateLuckDisplay();
        } else {
          updateLuckDisplay();
        }
      }, 1000);
    }

    function rollLuckWeighted(){
      const options = [
        {value:-1, weight:10},
        {value:0, weight:10},
        {value:1, weight:23},
        {value:2, weight:23},
        {value:3, weight:23},
        {value:4, weight:10},
        {value:10, weight:1}
      ];
      const total = options.reduce((s,o)=>s+o.weight,0);
      let r = Math.random()*total;
      for(let i=0;i<options.length;i++){
        if(r < options[i].weight) return options[i].value;
        r -= options[i].weight;
      }
      return options[options.length-1].value;
    }

    function pickNewLuck(){
      let newVal;
      let attempts = 0;
      do {
        newVal = rollLuckWeighted();
        attempts++;
        if(attempts>10) break;
      } while(newVal === lastLuck);
      lastLuck = newVal;
      saveState('luckLast', lastLuck);
      return newVal;
    }

    // initial display (restore persisted showing state)
    if(showing){
      luckValue = loadState('Luck', luckValue);
    } else {
      luckValue = loadState('Luck', null);
    }
    updateLuckDisplay();

    card.addEventListener('click', ()=>{
      const rem = getRemainingSec();
      if(rem > 0) {
        // cooling - ignore clicks
        return;
      }
      if(!showing){
        // roll and show
        luckValue = pickNewLuck();
        showing = true;
        saveState('Luck', luckValue);
        saveState('luckShowing', true);
        // start cooldown 60s
        startCooldown(60);
        card.classList.add('pulse');
        setTimeout(()=> card.classList.remove('pulse'), 520);
      } else {
        // currently showing and not cooling -> clicking hides value and returns to --
        showing = false;
        luckValue = null;
        saveState('Luck', null);
        saveState('luckShowing', false);
        updateLuckDisplay();
        card.classList.add('pulse');
        setTimeout(()=> card.classList.remove('pulse'), 320);
      }
    });

    if(cooldownUntil){
      const rem = getRemainingSec();
      if(rem>0){
        showing = true;
        saveState('luckShowing', true);
        updateLuckDisplay();
        if(timerId) clearInterval(timerId);
        timerId = setInterval(()=>{
          const r = getRemainingSec();
          if(r<=0){
            clearInterval(timerId); timerId=null;
            cooldownUntil = null;
            saveState('luckCooldownUntil', null);
            updateLuckDisplay();
          } else updateLuckDisplay();
        },1000);
      } else {
        cooldownUntil = null;
        saveState('luckCooldownUntil', null);
        updateLuckDisplay();
      }
    }

  } else {
    // Non-Luck attribute behavior
    let valNum = stored;
    let lockout = false;

    card.addEventListener('click', ()=>{
      if(lockout) return;
      // increment 0..9 loop
      valNum = (valNum + 1) % 10;
      val.textContent = String(valNum);
      saveState(name, valNum);

      // visual pulse
      card.classList.add('pulse');
      setTimeout(()=> card.classList.remove('pulse'), 420);

      // invisible 3-second lockout to prevent accidental double clicks
      lockout = true;
      setTimeout(()=> { lockout = false; }, 3000);
    });
  }
});

/* ========= Player name persistence and Enter handling ========= */
const playerNameInput = document.getElementById('playerName');
const existingName = loadState('playerName', '');
if(existingName) playerNameInput.value = existingName;
playerNameInput.addEventListener('keydown', (e)=>{
  if(e.key === 'Enter'){
    const nm = playerNameInput.value.trim();
    saveState('playerName', nm);
    playerNameInput.blur();
  }
});
playerNameInput.addEventListener('blur', ()=>{
  const nm = playerNameInput.value.trim();
  saveState('playerName', nm);
});

/* Reset button */
document.getElementById("resetBtn").onclick = () => {
  if (confirm("Are you sure you want to RESET ALL DATA?")) {
    localStorage.clear();
    location.reload();
  }
};
</script>
</body>
</html>
